<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN" "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<library id="poly_collection" name="Boost.PolyCollection" dirname="poly_collection"
last-revision="$Date: 2017/06/02 15:20:59 $" xmlns:xi="http://www.w3.org/2001/XInclude">
  <libraryinfo>
    <authorgroup>
    <author>
      <firstname>Joaquín M</firstname> <surname>López Muñoz</surname>
    </author>
    </authorgroup>
    <copyright>
      <year>2016</year> <year>2017</year> <holder>Joaquín M López Muñoz</holder>
    </copyright>
    <legalnotice id="poly_collection.legal">
      <para>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
      </para>
    </legalnotice>
    <librarypurpose>
      High-performance containers for polymorphic objects.
    </librarypurpose>
    <librarycategory name="category:containers"></librarycategory>
  </libraryinfo>
  <title>Boost.PolyCollection</title>
  <section id="poly_collection.introduction">
    <title><link linkend="poly_collection.introduction">Introduction</link></title>
    <warning>
      <para>
        Boost.PolyCollection has been accepted into Boost but it is yet to be released
        as part of an official Boost distribution.
      </para>
    </warning>
    <para>
      Dynamic polymorphism in C++ requires that objects (such as instances of classes
      derived from an abstract base) be accessed through an indirection pointer because
      their actual <emphasis>type</emphasis> and <emphasis>size</emphasis> are not
      known at the point of usage. As a consequence, regular containers cannot store
      polymorphic objects directly: the usual workaround is to have containers of
      pointers to heap-allocated elements. In modern computer architectures this
      pattern incurs in two types of inefficiency:
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          The lack of memory contiguity produced by heap allocation degrades CPU
          cache performance.
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          Executing virtual operations on a sequence of polymorphic objects whose
          actual types differ from one to the next results in failures in <ulink
          url="https://en.wikipedia.org/wiki/Branch_predictor">branch prediction</ulink>
          and a lower execution speed.
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      When the particular traversal order is not relevant to the user application,
      Boost.PolyCollection proposes an alternative data structure that restores memory
      contiguity and packs elements according to their concrete type. Three container
      class templates are provided:
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">base_collection</phrase></code>
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">function_collection</phrase></code>
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">any_collection</phrase></code>
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      respectively dealing with three different types of dynamic polymorphism available
      in C++:
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          Classic base/derived or OOP polymorphism.
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          Function wrapping in the spirit of <ulink url="http://en.cppreference.com/w/cpp/utility/functional/function"><code><phrase
          role="identifier">std</phrase><phrase role="special">::</phrase><phrase
          role="identifier">function</phrase></code></ulink>.
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          So-called <ulink url="https://en.wikipedia.org/wiki/Duck_typing"><emphasis>duck
          typing</emphasis></ulink> as implemented by <ulink url="http://www.boost.org/libs/type_erasure">Boost.TypeErasure</ulink>.
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      The interface of these containers closely follows that of standard containers.
      Additionally, the library provides versions of many of the standard library
      algorithms (including <ulink url="http://en.cppreference.com/w/cpp/algorithm/for_each"><code><phrase
      role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">for_each</phrase></code></ulink>)
      with improved performance and a special feature called <emphasis>type restitution</emphasis>
      that allows user code to provide clues on the concrete types of the elements
      stored for further opportunities of increased efficiency related to inlining
      and <ulink url="http://hubicka.blogspot.com.es/2014/01/devirtualization-in-c-part-1.html"><emphasis>devirtualization</emphasis></ulink>.
    </para>
    <note>
      <para>
        Boost.PolyCollection is a header-only library. C++11 support is required.
        The library has been verified to work with Visual Studio 2015, GCC 5.2 and
        Clang 3.7.
      </para>
    </note>
  </section>
  <section id="poly_collection.an_efficient_polymorphic_data_st">
    <title><link linkend="poly_collection.an_efficient_polymorphic_data_st">An efficient
    polymorphic data structure</link></title>
    <para>
      Suppose we have a <code><phrase role="identifier">base</phrase></code> abstract
      class with implementations <code><phrase role="identifier">derived1</phrase></code>,
      <code><phrase role="identifier">derived2</phrase></code> and <code><phrase
      role="identifier">derived3</phrase></code>. The memory layout of a <code><phrase
      role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase
      role="special">&lt;</phrase><phrase role="identifier">base</phrase><phrase
      role="special">*&gt;</phrase></code> (or similar constructs such as <code><phrase
      role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase
      role="special">&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
      role="identifier">unique_ptr</phrase><phrase role="special">&lt;</phrase><phrase
      role="identifier">base</phrase><phrase role="special">&gt;&gt;</phrase></code>
      or <ulink url="http://www.boost.org/libs/ptr_container/"><code><phrase role="identifier">boost</phrase><phrase
      role="special">::</phrase><phrase role="identifier">ptr_vector</phrase><phrase
      role="special">&lt;</phrase><phrase role="identifier">base</phrase><phrase
      role="special">&gt;</phrase></code></ulink>) looks like the following:
    </para>
    <para>
      <inlinemediaobject><imageobject><imagedata fileref="img/ptr_vector.png"></imagedata></imageobject></inlinemediaobject>
    </para>
    <para>
      Elements that are adjacent in the vector are not necessarily allocated contiguously,
      much less so if the vector has undergone mid insertions and deletions. A typical
      processing operation
    </para>
<programlisting><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">base</phrase><phrase role="special">*&gt;</phrase> <phrase role="identifier">v</phrase><phrase role="special">;</phrase>
<phrase role="special">...</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="identifier">base</phrase><phrase role="special">*</phrase> <phrase role="identifier">b</phrase><phrase role="special">:</phrase> <phrase role="identifier">v</phrase><phrase role="special">){</phrase>
  <phrase role="special">...</phrase> <phrase role="comment">// access base's virtual interface</phrase>
<phrase role="special">}</phrase>
</programlisting>
    <para>
      is impacted negatively by two factors:
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          Scattering of elements throughout memory reduces CPU caching efficiency,
          which in general favor regular access loops to contiguous memory areas.
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <ulink url="https://en.wikipedia.org/wiki/Branch_predictor">Branch prediction</ulink>
          tries to minimize the effect of running conditional code (such as an <code><phrase
          role="keyword">if</phrase></code>-<code><phrase role="keyword">else</phrase></code>
          statement or the invocation of a <code><phrase role="identifier">base</phrase></code>
          virtual function) by speculatively executing a given branch based on past
          history. This mechanism is rendered mostly useless when <code><phrase role="identifier">derived1</phrase></code>,
          <code><phrase role="identifier">derived2</phrase></code> and <code><phrase
          role="identifier">derived3</phrase></code> elements are traversed interspersedly
          without a definite pattern.
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      These limitations are imposed by the very nature of dynamic polymorphism: as
      the exact types of the elements accessed through <code><phrase role="identifier">base</phrase></code>'s
      interface are not known, an indirection through <code><phrase role="identifier">base</phrase><phrase
      role="special">*</phrase></code> (a particular form of <emphasis>type erasure</emphasis>)
      is required. There is however a critical observation: even though derived types
      are not known when traversing a <code><phrase role="identifier">std</phrase><phrase
      role="special">::</phrase><phrase role="identifier">vector</phrase><phrase
      role="special">&lt;</phrase><phrase role="identifier">base</phrase><phrase
      role="special">*&gt;</phrase></code>, the information is typically available
      <emphasis>at compile time</emphasis> in the point of insertion in the vector:
    </para>
<programlisting><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">base</phrase><phrase role="special">*&gt;</phrase> <phrase role="identifier">v</phrase><phrase role="special">;</phrase>
<phrase role="special">...</phrase>
<phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="keyword">new</phrase> <phrase role="identifier">derived2</phrase><phrase role="special">{...});</phrase> <phrase role="comment">// the type derived2 is &quot;forgotten&quot; by v</phrase>
</programlisting>
    <para>
      A suitably designed container can take advantage of this information to arrange
      elements contiguously according to their exact type, which results in an internal
      data structure (a map of <ulink url="http://en.cppreference.com/w/cpp/types/type_index"><code><phrase
      role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase></code></ulink>
      objects, actually) pointing to as many vectors or <emphasis>segments</emphasis>
      as there are derived classes:
    </para>
    <para>
      <inlinemediaobject><imageobject><imagedata fileref="img/segment_map.png"></imagedata></imageobject></inlinemediaobject>
    </para>
    <para>
      Traversing such a structure reduces to looping over all the segments one after
      another: this is extremely efficient both in terms of caching and branch prediction.
      In the process we have however lost the free-order capability of a <code><phrase
      role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase
      role="special">&lt;</phrase><phrase role="identifier">base</phrase><phrase
      role="special">*&gt;</phrase></code> (free order can only be retained at the
      segment level), but if this is not relevant to the user application the potential
      performance gains of switching to this structure are large.
    </para>
    <para>
      The discussion has focused on base/derived programming, also known as OOP,
      but it also applies to other forms of dynamic polymorphism:
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          <ulink url="http://en.cppreference.com/w/cpp/utility/functional/function"><code><phrase
          role="identifier">std</phrase><phrase role="special">::</phrase><phrase
          role="identifier">function</phrase></code></ulink> abstracts callable entities
          with the same given signature under a common interface. Internally, pointer
          indirections and virtual-like function calls are used. Memory fragmentation
          is expected to be lower than with OOP, though, as implementations usually
          feature the so-called <emphasis>small buffer optimization</emphasis> to
          avoid heap allocation in some situations.
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          The case of <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
          role="identifier">function</phrase></code> can be seen as a particular
          example of a more general form of polymorphism called <ulink url="https://en.wikipedia.org/wiki/Duck_typing"><emphasis>duck
          typing</emphasis></ulink>, where unrelated types are treated uniformly
          if they conform to the same given <emphasis>interface</emphasis> (a specified
          set of member functions and/or operations). Duck typing provides the power
          of OOP while allowing for greater flexibility as polymorphic types need
          not derive from a preexisting base class or in general be designed with
          any particular interface in mind --in fact, the same object can be duck-typed
          to different interfaces. Among other libraries, <ulink url="http://www.boost.org/libs/type_erasure">Boost.TypeErasure</ulink>
          provides duck typing for C++. Under the hood, duck typing requires pointer
          indirection and virtual call implementation techniques analogous to those
          of OOP, and so there are the same opportunities for efficient container
          data structures as we have described.
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      Boost.PolyCollection provides three different container class templates dealing
      with OOP, <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
      role="identifier">function</phrase></code>-like polymorphism and duck typing
      as implemented by Boost.TypeErasure:
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">base_collection</phrase></code>
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">function_collection</phrase></code>
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">any_collection</phrase></code>
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      The interfaces of these containers are mostly the same and follow the usual
      conventions of standard library containers.
    </para>
  </section>
  <section id="poly_collection.tutorial">
    <title><link linkend="poly_collection.tutorial">Tutorial</link></title>
    <section id="poly_collection.tutorial.basics">
      <title><link linkend="poly_collection.tutorial.basics">Basics</link></title>
      <section id="poly_collection.tutorial.basics.boost_base_collection">
        <title><link linkend="poly_collection.tutorial.basics.boost_base_collection"><code><phrase
        role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">base_collection</phrase></code></link></title>
        <para>
          (Code samples from <ulink url="../../example/basic_base.cpp"><code><phrase
          role="identifier">basic_base</phrase><phrase role="special">.</phrase><phrase
          role="identifier">cpp</phrase></code></ulink>.)
        </para>
        <para>
          Imagine we are developing a role game in C++ where sprites are rendered
          on screen; for the purposes of illustration we can model rendering simply
          as outputting some information to a <code><phrase role="identifier">std</phrase><phrase
          role="special">::</phrase><phrase role="identifier">ostream</phrase></code>:
        </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">sprite</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">sprite</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">id</phrase><phrase role="special">):</phrase><phrase role="identifier">id</phrase><phrase role="special">(</phrase><phrase role="identifier">id</phrase><phrase role="special">){}</phrase>
  <phrase role="keyword">virtual</phrase> <phrase role="special">~</phrase><phrase role="identifier">sprite</phrase><phrase role="special">()=</phrase><phrase role="keyword">default</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">virtual</phrase> <phrase role="keyword">void</phrase> <phrase role="identifier">render</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">os</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">int</phrase> <phrase role="identifier">id</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
        <para>
          The game features warriors, juggernauts (a special type of warrior) and
          goblins, each represented by its own class derived (directly or indirectly)
          from <code><phrase role="identifier">sprite</phrase></code>:
        </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">warrior</phrase><phrase role="special">:</phrase><phrase role="identifier">sprite</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">sprite</phrase><phrase role="special">::</phrase><phrase role="identifier">sprite</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">warrior</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">rank</phrase><phrase role="special">,</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">id</phrase><phrase role="special">):</phrase><phrase role="identifier">sprite</phrase><phrase role="special">{</phrase><phrase role="identifier">id</phrase><phrase role="special">},</phrase><phrase role="identifier">rank</phrase><phrase role="special">{</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase><phrase role="identifier">rank</phrase><phrase role="special">)}{}</phrase>

  <phrase role="keyword">virtual</phrase> <phrase role="keyword">void</phrase> <phrase role="identifier">render</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">os</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">{</phrase><phrase role="identifier">os</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">rank</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot; &quot;</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">id</phrase><phrase role="special">;};</phrase>

  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">rank</phrase><phrase role="special">=</phrase><phrase role="string">&quot;warrior&quot;</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">juggernaut</phrase><phrase role="special">:</phrase><phrase role="identifier">warrior</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">juggernaut</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">id</phrase><phrase role="special">):</phrase><phrase role="identifier">warrior</phrase><phrase role="special">{</phrase><phrase role="string">&quot;juggernaut&quot;</phrase><phrase role="special">,</phrase><phrase role="identifier">id</phrase><phrase role="special">}{}</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">goblin</phrase><phrase role="special">:</phrase><phrase role="identifier">sprite</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">sprite</phrase><phrase role="special">::</phrase><phrase role="identifier">sprite</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">virtual</phrase> <phrase role="keyword">void</phrase> <phrase role="identifier">render</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">os</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">{</phrase><phrase role="identifier">os</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;goblin &quot;</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">id</phrase><phrase role="special">;};</phrase>
<phrase role="special">};</phrase>
</programlisting>
        <para>
          Let us populate a polymorphic collection with an assortment of sprites:
        </para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">poly_collection</phrase><phrase role="special">/</phrase><phrase role="identifier">base_collection</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="special">...</phrase>

<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">sprite</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">c</phrase><phrase role="special">;</phrase>

<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">mt19937</phrase>                     <phrase role="identifier">gen</phrase><phrase role="special">{</phrase><phrase role="number">92748</phrase><phrase role="special">};</phrase> <phrase role="comment">// some arbitrary random seed</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">uniform_real_distribution</phrase><phrase role="special">&lt;&gt;</phrase> <phrase role="identifier">rnd</phrase><phrase role="special">;</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">;</phrase><phrase role="identifier">i</phrase><phrase role="special">&lt;</phrase><phrase role="number">8</phrase><phrase role="special">;++</phrase><phrase role="identifier">i</phrase><phrase role="special">){</phrase> <phrase role="comment">// assign each type with 1/3 probability</phrase>
  <phrase role="keyword">auto</phrase> <phrase role="identifier">r</phrase><phrase role="special">=</phrase><phrase role="identifier">rnd</phrase><phrase role="special">(</phrase><phrase role="identifier">gen</phrase><phrase role="special">);</phrase>
       <phrase role="keyword">if</phrase><phrase role="special">(</phrase><phrase role="identifier">r</phrase><phrase role="special">&lt;</phrase><phrase role="number">1.0</phrase><phrase role="special">/</phrase><phrase role="number">3</phrase><phrase role="special">)</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">warrior</phrase><phrase role="special">{</phrase><phrase role="identifier">i</phrase><phrase role="special">});</phrase>
  <phrase role="keyword">else</phrase> <phrase role="keyword">if</phrase><phrase role="special">(</phrase><phrase role="identifier">r</phrase><phrase role="special">&lt;</phrase><phrase role="number">2.0</phrase><phrase role="special">/</phrase><phrase role="number">3</phrase><phrase role="special">)</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">{</phrase><phrase role="identifier">i</phrase><phrase role="special">});</phrase>
  <phrase role="keyword">else</phrase>            <phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">goblin</phrase><phrase role="special">{</phrase><phrase role="identifier">i</phrase><phrase role="special">});</phrase>
<phrase role="special">}</phrase>
</programlisting>
        <para>
          There are two aspects to notice here:
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
              role="identifier">base_collection</phrase></code> does not have a
              <code><phrase role="identifier">push_back</phrase></code> member function
              like, say, <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
              role="identifier">vector</phrase></code>, as the order in which elements
              are stored cannot be freely chosen by the user code --we will see more
              about this later. Insertion mechanisms are rather those of containers
              like <ulink url="http://en.cppreference.com/w/cpp/container/unordered_multiset"><code><phrase
              role="identifier">std</phrase><phrase role="special">::</phrase><phrase
              role="identifier">unordered_multiset</phrase></code></ulink>, namely
              <code><phrase role="identifier">insert</phrase></code> and <code><phrase
              role="identifier">emplace</phrase></code> with or without a position
              <emphasis>hint</emphasis>.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              Elements are not created with <code><phrase role="keyword">new</phrase></code>
              but constructed on the stack and passed directly much like one would
              do with a standard non-polymorphic container.
            </simpara>
          </listitem>
        </itemizedlist>
        <important>
          <para>
            Elements inserted into a <code><phrase role="identifier">boost</phrase><phrase
            role="special">::</phrase><phrase role="identifier">base_collection</phrase></code>
            (or the other containers of Boost.PolyCollection) must be copyable and
            assignable; strictly speaking, they must at least model <ulink url="http://en.cppreference.com/w/cpp/concept/MoveConstructible"><emphasis
            role="bold"><code><phrase role="identifier">MoveConstructible</phrase></code></emphasis></ulink>
            and either be <ulink url="http://en.cppreference.com/w/cpp/concept/MoveAssignable"><emphasis
            role="bold"><code><phrase role="identifier">MoveAssignable</phrase></code></emphasis></ulink>
            or not throw on move construction. This might force you to revisit your
            code as it is customary to explicitly forbid copying at the base level
            of a virtual hierarchy to avoid <ulink url="https://en.wikipedia.org/wiki/Object_slicing"><emphasis>slicing</emphasis></ulink>.
          </para>
        </important>
        <para>
          Rendering can now be implemented with a simple <code><phrase role="keyword">for</phrase></code>
          loop over <code><phrase role="identifier">c</phrase></code>:
        </para>
<programlisting><phrase role="keyword">const</phrase> <phrase role="keyword">char</phrase><phrase role="special">*</phrase> <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;&quot;</phrase><phrase role="special">;</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">sprite</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">s</phrase><phrase role="special">:</phrase><phrase role="identifier">c</phrase><phrase role="special">){</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">comma</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">s</phrase><phrase role="special">.</phrase><phrase role="identifier">render</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">);</phrase>
  <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;,&quot;</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          The output being:
        </para>
<programlisting>juggernaut 0,juggernaut 4,juggernaut 7,goblin 1,goblin 3,goblin 5,warrior 2,warrior 6
</programlisting>
        <para>
          As we have forewarned, the traversal order does not correspond to that
          of insertion. Instead, the elements are grouped in <emphasis>segments</emphasis>
          according to their concrete type. Here we see that juggernauts come first,
          followed by goblins and warriors. In general, no assumptions should be
          made about segment ordering, which may be different for this very example
          in your environment. On the other hand, elements inserted into an already
          existing segment always come at the end (except if a hint is provided).
          For instance, after inserting a latecomer goblin with <code><phrase role="identifier">id</phrase><phrase
          role="special">==</phrase><phrase role="number">8</phrase></code>:
        </para>
<programlisting><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">goblin</phrase><phrase role="special">{</phrase><phrase role="number">8</phrase><phrase role="special">});</phrase>
</programlisting>
        <para>
          the rendering loop outputs (new element in red):
        </para>
<programlisting>juggernaut 0,juggernaut 4,juggernaut 7,goblin 1,goblin 3,goblin 5,<phrase role="red">goblin 8</phrase>,warrior 2,warrior 6
</programlisting>
        <para>
          Deletion can be done in the usual way:
        </para>
<programlisting><phrase role="comment">// find element with id==7 and remove it</phrase>
<phrase role="keyword">auto</phrase> <phrase role="identifier">it</phrase><phrase role="special">=</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">find_if</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),[](</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">sprite</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">s</phrase><phrase role="special">){</phrase><phrase role="keyword">return</phrase> <phrase role="identifier">s</phrase><phrase role="special">.</phrase><phrase role="identifier">id</phrase><phrase role="special">==</phrase><phrase role="number">7</phrase><phrase role="special">;});</phrase>
<phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">erase</phrase><phrase role="special">(</phrase><phrase role="identifier">it</phrase><phrase role="special">);</phrase>
</programlisting>
        <para>
          Now rendering emits:
        </para>
<programlisting>juggernaut 0,juggernaut 4,goblin 1,goblin 3,goblin 5,goblin 8,warrior 2,warrior 6
</programlisting>
      </section>
      <section id="poly_collection.tutorial.basics.boost_function_collection">
        <title><link linkend="poly_collection.tutorial.basics.boost_function_collection"><code><phrase
        role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">function_collection</phrase></code></link></title>
        <para>
          (Code samples from <ulink url="../../example/basic_function.cpp"><code><phrase
          role="identifier">basic_function</phrase><phrase role="special">.</phrase><phrase
          role="identifier">cpp</phrase></code></ulink>.)
        </para>
        <para>
          Well into the development of the game, the product manager requests that
          two new types of entities be added to the rendering loop:
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              Overlaid messages, such as scores, modelled as <code><phrase role="identifier">std</phrase><phrase
              role="special">::</phrase><phrase role="identifier">string</phrase></code>s.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              Pop-up windows coming from a third party library that, unfortunately,
              do not derive from <code><phrase role="identifier">sprite</phrase></code>
              and use their own <code><phrase role="identifier">display</phrase></code>
              member functon for rendering:
            </simpara>
          </listitem>
        </itemizedlist>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">window</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">window</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">caption</phrase><phrase role="special">):</phrase><phrase role="identifier">caption</phrase><phrase role="special">{</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase><phrase role="identifier">caption</phrase><phrase role="special">)}{}</phrase>

  <phrase role="keyword">void</phrase> <phrase role="identifier">display</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">os</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">{</phrase><phrase role="identifier">os</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;[&quot;</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">caption</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;]&quot;</phrase><phrase role="special">;}</phrase>

  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">caption</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
        <para>
          We then decide to refactor the code so that sprites, messsages and windows
          are stored in dedicated containers:
        </para>
<programlisting><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">unique_ptr</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">sprite</phrase><phrase role="special">&gt;&gt;</phrase> <phrase role="identifier">sprs</phrase><phrase role="special">;</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">&gt;</phrase>             <phrase role="identifier">msgs</phrase><phrase role="special">;</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">window</phrase><phrase role="special">&gt;</phrase>                  <phrase role="identifier">wnds</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          and define our rendering container as a <code><phrase role="identifier">boost</phrase><phrase
          role="special">::</phrase><phrase role="identifier">function_collection</phrase></code>
          of callable entities accepting a <code><phrase role="identifier">std</phrase><phrase
          role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase
          role="special">&amp;</phrase></code> as a parameter
        </para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">poly_collection</phrase><phrase role="special">/</phrase><phrase role="identifier">function_collection</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="special">...</phrase>

<phrase role="comment">// function signature accepting std::ostream&amp; and returning nothing</phrase>
<phrase role="keyword">using</phrase> <phrase role="identifier">render_callback</phrase><phrase role="special">=</phrase><phrase role="keyword">void</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;);</phrase>
<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">render_callback</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">c</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          which we fill with suitable adaptors for <code><phrase role="identifier">sprite</phrase></code>s,
          <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
          role="identifier">string</phrase></code>s and <code><phrase role="identifier">window</phrase></code>s,
          respectively. Lambda functions allow for a particularly terse code.
        </para>
<programlisting><phrase role="keyword">auto</phrase> <phrase role="identifier">render_sprite</phrase><phrase role="special">=[](</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">sprite</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">s</phrase><phrase role="special">){</phrase>
  <phrase role="keyword">return</phrase> <phrase role="special">[&amp;](</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">os</phrase><phrase role="special">){</phrase><phrase role="identifier">s</phrase><phrase role="special">.</phrase><phrase role="identifier">render</phrase><phrase role="special">(</phrase><phrase role="identifier">os</phrase><phrase role="special">);};</phrase>
<phrase role="special">};</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">auto</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">ps</phrase><phrase role="special">:</phrase><phrase role="identifier">sprs</phrase><phrase role="special">)</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">render_sprite</phrase><phrase role="special">(*</phrase><phrase role="identifier">ps</phrase><phrase role="special">));</phrase>

<phrase role="keyword">auto</phrase> <phrase role="identifier">render_message</phrase><phrase role="special">=[](</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">m</phrase><phrase role="special">){</phrase>
  <phrase role="keyword">return</phrase> <phrase role="special">[&amp;](</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">os</phrase><phrase role="special">){</phrase><phrase role="identifier">os</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">m</phrase><phrase role="special">;};</phrase>
<phrase role="special">};</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">auto</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">m</phrase><phrase role="special">:</phrase><phrase role="identifier">msgs</phrase><phrase role="special">)</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">render_message</phrase><phrase role="special">(</phrase><phrase role="identifier">m</phrase><phrase role="special">));</phrase>

<phrase role="keyword">auto</phrase> <phrase role="identifier">render_window</phrase><phrase role="special">=[](</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">window</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">w</phrase><phrase role="special">){</phrase>
  <phrase role="keyword">return</phrase> <phrase role="special">[&amp;](</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">os</phrase><phrase role="special">){</phrase><phrase role="identifier">w</phrase><phrase role="special">.</phrase><phrase role="identifier">display</phrase><phrase role="special">(</phrase><phrase role="identifier">os</phrase><phrase role="special">);};</phrase>
<phrase role="special">};</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">auto</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">w</phrase><phrase role="special">:</phrase><phrase role="identifier">wnds</phrase><phrase role="special">)</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">render_window</phrase><phrase role="special">(</phrase><phrase role="identifier">w</phrase><phrase role="special">));</phrase>
</programlisting>
        <para>
          The rendering loop now looks like this:
        </para>
<programlisting><phrase role="keyword">const</phrase> <phrase role="keyword">char</phrase><phrase role="special">*</phrase> <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;&quot;</phrase><phrase role="special">;</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">auto</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">cbk</phrase><phrase role="special">:</phrase><phrase role="identifier">c</phrase><phrase role="special">){</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">comma</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">cbk</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">);</phrase>
  <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;,&quot;</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          and produces the following for a particular scenario of sprites, messages
          and windows:
        </para>
<programlisting>juggernaut 0,goblin 1,warrior 2,goblin 3,&quot;stamina: 10,000&quot;,&quot;game over&quot;,<!--quickbook-escape-prefix-->[pop-up 1]<!--quickbook-escape-postfix-->,<!--quickbook-escape-prefix-->[pop-up 2]<!--quickbook-escape-postfix-->
</programlisting>
        <para>
          (Note that all sprites come into one segment: this is why goblins #1 and
          #3 are not adjacent <footnote id="poly_collection.tutorial.basics.boost_function_collection.f0">
          <para>
            Exercise for the reader: change the code of the example so that sprites
            are further segmented according to their concrete type.
          </para>
          </footnote>.)
        </para>
        <para>
          The <code><phrase role="identifier">value_type</phrase></code> elements
          held by a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">function_collection</phrase></code> are actually <emphasis>not</emphasis>
          <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
          role="identifier">function</phrase></code>s, althouth they behave analogously
          and can be converted to <code><phrase role="identifier">std</phrase><phrase
          role="special">::</phrase><phrase role="identifier">function</phrase></code>
          if needed:
        </para>
<programlisting><phrase role="keyword">auto</phrase> <phrase role="identifier">cbk</phrase><phrase role="special">=*</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">();</phrase>
<phrase role="identifier">cbk</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">);</phrase> <phrase role="comment">// renders first element to std::cout</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">function</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">render_callback</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">f</phrase><phrase role="special">=</phrase><phrase role="identifier">cbk</phrase><phrase role="special">;</phrase>
<phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">);</phrase>   <phrase role="comment">// exactly the same</phrase>
</programlisting>
        <para>
          There is a reason for this: elements of a polymorphic collection cannot
          be freely assigned to by the user as this could end up trying to insert
          an object into a segment of a different type. So, unlike with <code><phrase
          role="identifier">std</phrase><phrase role="special">::</phrase><phrase
          role="identifier">function</phrase></code>, this will not work:
        </para>
<programlisting><phrase role="special">*</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">()=</phrase><phrase role="identifier">render_message</phrase><phrase role="special">(</phrase><phrase role="string">&quot;last minute message&quot;</phrase><phrase role="special">);</phrase> <phrase role="comment">// compile-time error</phrase>
</programlisting>
      </section>
      <section id="poly_collection.tutorial.basics.boost_any_collection">
        <title><link linkend="poly_collection.tutorial.basics.boost_any_collection"><code><phrase
        role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">any_collection</phrase></code></link></title>
        <para>
          (Code samples from <ulink url="../../example/basic_any.cpp"><code><phrase
          role="identifier">basic_any</phrase><phrase role="special">.</phrase><phrase
          role="identifier">cpp</phrase></code></ulink>.)
        </para>
        <note>
          <para>
            Here we just touch on the bare essentials of <ulink url="http://www.boost.org/libs/type_erasure">Boost.TypeErasure</ulink>
            needed to present <code><phrase role="identifier">boost</phrase><phrase
            role="special">::</phrase><phrase role="identifier">any_collection</phrase></code>.
            The reader is advised to read Boost.TypeErasure documentation for further
            information.
          </para>
        </note>
        <para>
          After measuring the performance of the latest changes, we find that rendering
          is too slow and decide to refactor once again: if we could store all the
          entities --sprites, messages and windows-- into one single container, that
          would eliminate a level of indirection. The problem is that these types
          are totally unrelated to each other.
        </para>
        <para>
          <ulink url="http://www.boost.org/libs/type_erasure">Boost.TypeErasure</ulink>
          provides a class template <code><phrase role="identifier">boost</phrase><phrase
          role="special">::</phrase><phrase role="identifier">type_erasure</phrase><phrase
          role="special">::</phrase><phrase role="identifier">any</phrase><phrase
          role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase
          role="special">&gt;</phrase></code> able to hold an object of whatever
          type as long as it conforms to the interface specified by <code><phrase
          role="identifier">Concept</phrase></code>. In our case, we find it particularly
          easy to implement a common interface for rendering by providing overloads
          of <code><phrase role="keyword">operator</phrase><phrase role="special">&lt;&lt;</phrase></code>
        </para>
<programlisting><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">&lt;&lt;(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">os</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">sprite</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">s</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">s</phrase><phrase role="special">.</phrase><phrase role="identifier">render</phrase><phrase role="special">(</phrase><phrase role="identifier">os</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">return</phrase> <phrase role="identifier">os</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>

<phrase role="comment">// std::string already has a suitable operator&lt;&lt;</phrase>

<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">&lt;&lt;(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">os</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">window</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">w</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">w</phrase><phrase role="special">.</phrase><phrase role="identifier">display</phrase><phrase role="special">(</phrase><phrase role="identifier">os</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">return</phrase> <phrase role="identifier">os</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
        <para>
          so that we can use it to specify the interface all entities have to adhere
          to:
        </para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">poly_collection</phrase><phrase role="special">/</phrase><phrase role="identifier">any_collection</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">type_erasure</phrase><phrase role="special">/</phrase><phrase role="identifier">operators</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="special">...</phrase>

<phrase role="keyword">using</phrase> <phrase role="identifier">renderable</phrase><phrase role="special">=</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">type_erasure</phrase><phrase role="special">::</phrase><phrase role="identifier">ostreamable</phrase><phrase role="special">&lt;&gt;;</phrase>
<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">renderable</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">c</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          The collection just created happily accepts insertion of heterogeneous
          entities (since interface conformity is silently checked at compile time)
        </para>
<programlisting><phrase role="comment">// populate with sprites</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">mt19937</phrase>                     <phrase role="identifier">gen</phrase><phrase role="special">{</phrase><phrase role="number">92748</phrase><phrase role="special">};</phrase> <phrase role="comment">// some arbitrary random seed</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">uniform_real_distribution</phrase><phrase role="special">&lt;&gt;</phrase> <phrase role="identifier">rnd</phrase><phrase role="special">;</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">;</phrase><phrase role="identifier">i</phrase><phrase role="special">&lt;</phrase><phrase role="number">4</phrase><phrase role="special">;++</phrase><phrase role="identifier">i</phrase><phrase role="special">){</phrase> <phrase role="comment">// assign each type with 1/3 probability</phrase>
  <phrase role="keyword">auto</phrase> <phrase role="identifier">r</phrase><phrase role="special">=</phrase><phrase role="identifier">rnd</phrase><phrase role="special">(</phrase><phrase role="identifier">gen</phrase><phrase role="special">);</phrase>
       <phrase role="keyword">if</phrase><phrase role="special">(</phrase><phrase role="identifier">r</phrase><phrase role="special">&lt;</phrase><phrase role="number">1.0</phrase><phrase role="special">/</phrase><phrase role="number">3</phrase><phrase role="special">)</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">warrior</phrase><phrase role="special">{</phrase><phrase role="identifier">i</phrase><phrase role="special">});</phrase>
  <phrase role="keyword">else</phrase> <phrase role="keyword">if</phrase><phrase role="special">(</phrase><phrase role="identifier">r</phrase><phrase role="special">&lt;</phrase><phrase role="number">2.0</phrase><phrase role="special">/</phrase><phrase role="number">3</phrase><phrase role="special">)</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">{</phrase><phrase role="identifier">i</phrase><phrase role="special">});</phrase>
  <phrase role="keyword">else</phrase>            <phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">goblin</phrase><phrase role="special">{</phrase><phrase role="identifier">i</phrase><phrase role="special">});</phrase>
<phrase role="special">}</phrase>

<phrase role="comment">// populate with messages</phrase>
<phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">{</phrase><phrase role="string">&quot;\&quot;stamina: 10,000\&quot;&quot;</phrase><phrase role="special">});</phrase>
<phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">{</phrase><phrase role="string">&quot;\&quot;game over\&quot;&quot;</phrase><phrase role="special">});</phrase>

<phrase role="comment">// populate with windows</phrase>
<phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">window</phrase><phrase role="special">{</phrase><phrase role="string">&quot;pop-up 1&quot;</phrase><phrase role="special">});</phrase>
<phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">window</phrase><phrase role="special">{</phrase><phrase role="string">&quot;pop-up 2&quot;</phrase><phrase role="special">});</phrase>
</programlisting>
        <para>
          and rendering becomes
        </para>
<programlisting><phrase role="keyword">const</phrase> <phrase role="keyword">char</phrase><phrase role="special">*</phrase> <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;&quot;</phrase><phrase role="special">;</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">auto</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">r</phrase><phrase role="special">:</phrase><phrase role="identifier">c</phrase><phrase role="special">){</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">comma</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">r</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;,&quot;</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          with output
        </para>
<programlisting><!--quickbook-escape-prefix-->[pop-up 1]<!--quickbook-escape-postfix-->,<!--quickbook-escape-prefix-->[pop-up 2]<!--quickbook-escape-postfix-->,juggernaut 0,goblin 1,goblin 3,warrior 2,&quot;stamina: 10,000&quot;,&quot;game over&quot;
</programlisting>
        <para>
          As was the case with <code><phrase role="identifier">boost</phrase><phrase
          role="special">::</phrase><phrase role="identifier">function_collection</phrase></code>,
          the <code><phrase role="identifier">value_type</phrase></code> of a <code><phrase
          role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">Concept</phrase><phrase role="special">&gt;</phrase></code>
          is <emphasis>not</emphasis> <code><phrase role="identifier">boost</phrase><phrase
          role="special">::</phrase><phrase role="identifier">type_erasure</phrase><phrase
          role="special">::</phrase><phrase role="identifier">any</phrase><phrase
          role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase
          role="special">&gt;</phrase></code>, but a similarly behaving entity <footnote
          id="poly_collection.tutorial.basics.boost_any_collection.f0">
          <para>
            Actually, it is <code><phrase role="identifier">boost</phrase><phrase
            role="special">::</phrase><phrase role="identifier">type_erasure</phrase><phrase
            role="special">::</phrase><phrase role="identifier">any</phrase><phrase
            role="special">&lt;</phrase><phrase role="identifier">Concept2</phrase><phrase
            role="special">,</phrase><phrase role="identifier">boost</phrase><phrase
            role="special">::</phrase><phrase role="identifier">type_erasure</phrase><phrase
            role="special">::</phrase><phrase role="identifier">_self</phrase><phrase
            role="special">&amp;&gt;</phrase></code> for some internally defined
            <code><phrase role="identifier">Concept2</phrase></code> that extends
            <code><phrase role="identifier">Concept</phrase></code>.
          </para>
          </footnote>. In any case, we are not accessing sprites through an abstract
          <code><phrase role="identifier">sprite</phrase><phrase role="special">&amp;</phrase></code>
          anymore, so we could as well dismantle the virtual hierarchy and implement
          each type autonomously: this is left as an exercise to the reader.
        </para>
      </section>
    </section>
    <section id="poly_collection.tutorial.deeper_into_the_segmented_nature">
      <title><link linkend="poly_collection.tutorial.deeper_into_the_segmented_nature">Deeper
      into the segmented nature of Boost.PolyCollection</link></title>
      <para>
        (Code samples from <ulink url="../../example/segmented_structure.cpp"><code><phrase
        role="identifier">segmented_structure</phrase><phrase role="special">.</phrase><phrase
        role="identifier">cpp</phrase></code></ulink>.)
      </para>
      <section id="poly_collection.tutorial.deeper_into_the_segmented_nature.type_registration">
        <title><link linkend="poly_collection.tutorial.deeper_into_the_segmented_nature.type_registration">Type
        registration</link></title>
        <para>
          Getting back to our <link linkend="poly_collection.tutorial.basics.boost_base_collection"><code><phrase
          role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">base_collection</phrase></code></link> example, suppose
          we want to refactor the populating code as follows:
        </para>
<programlisting><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">unique_ptr</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">sprite</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">make_sprite</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">static</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">mt19937</phrase>                     <phrase role="identifier">gen</phrase><phrase role="special">{</phrase><phrase role="number">92748</phrase><phrase role="special">};</phrase>
  <phrase role="keyword">static</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">uniform_real_distribution</phrase><phrase role="special">&lt;&gt;</phrase> <phrase role="identifier">rnd</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">static</phrase> <phrase role="keyword">int</phrase>                              <phrase role="identifier">id</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">auto</phrase> <phrase role="identifier">r</phrase><phrase role="special">=</phrase><phrase role="identifier">rnd</phrase><phrase role="special">(</phrase><phrase role="identifier">gen</phrase><phrase role="special">);</phrase>
       <phrase role="keyword">if</phrase><phrase role="special">(</phrase><phrase role="identifier">r</phrase><phrase role="special">&lt;</phrase><phrase role="number">1.0</phrase><phrase role="special">/</phrase><phrase role="number">3</phrase><phrase role="special">)</phrase><phrase role="keyword">return</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">make_unique</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">warrior</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">id</phrase><phrase role="special">++);</phrase>
  <phrase role="keyword">else</phrase> <phrase role="keyword">if</phrase><phrase role="special">(</phrase><phrase role="identifier">r</phrase><phrase role="special">&lt;</phrase><phrase role="number">2.0</phrase><phrase role="special">/</phrase><phrase role="number">3</phrase><phrase role="special">)</phrase><phrase role="keyword">return</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">make_unique</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">id</phrase><phrase role="special">++);</phrase>
  <phrase role="keyword">else</phrase>            <phrase role="keyword">return</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">make_unique</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">goblin</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">id</phrase><phrase role="special">++);</phrase>
<phrase role="special">}</phrase>
<phrase role="special">...</phrase>

<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">;</phrase><phrase role="identifier">i</phrase><phrase role="special">&lt;</phrase><phrase role="number">8</phrase><phrase role="special">;++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(*</phrase><phrase role="identifier">make_sprite</phrase><phrase role="special">());</phrase>
<phrase role="comment">// throws boost::poly_collection::unregistered_type</phrase>
</programlisting>
        <para>
          Unexpectedly, this piece of code throws an exception of type <link linkend="poly_collection.reference.header_boost_poly_collection_exc.class_unregistered_type"><code><phrase
          role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase
          role="identifier">unregistered_type</phrase></code></link>. What has changed
          from our original code?
        </para>
        <para>
          Suppose a <code><phrase role="identifier">warrior</phrase></code> has been
          created by <code><phrase role="identifier">make_sprite</phrase></code>.
          The statement <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
          role="identifier">insert</phrase><phrase role="special">(*</phrase><phrase
          role="identifier">make_sprite</phrase><phrase role="special">())</phrase></code>
          is passing the object as a <code><phrase role="identifier">sprite</phrase><phrase
          role="special">&amp;</phrase></code>: even though <code><phrase role="identifier">boost</phrase><phrase
          role="special">::</phrase><phrase role="identifier">base_collection</phrase></code>
          is smart enough to know that the object is actually derived from <code><phrase
          role="identifier">sprite</phrase></code> (by using <ulink url="http://en.cppreference.com/w/cpp/language/typeid"><code><phrase
          role="keyword">typeid</phrase><phrase role="special">()</phrase></code></ulink>)
          and <ulink url="https://en.wikipedia.org/wiki/Object_slicing">slicing</ulink>
          is to be avoided, there is no way that a segment for it can be created
          without accessing the type <code><phrase role="identifier">warrior</phrase></code>
          <emphasis>at compile time</emphasis> for the proper internal class templates
          to be instantiated <footnote id="poly_collection.tutorial.deeper_into_the_segmented_nature.type_registration.f0">
          <para>
            If this is conceptually difficult to grasp, consider the potentially
            more obvious case where <code><phrase role="identifier">warrior</phrase></code>
            is defined in a dynamic module linked to the main program: the code of
            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
            role="identifier">base_collection</phrase></code>, which has been compiled
            before linking, cannot even know the size of this as-of-yet unseen class,
            so hardly can it allocate a segment for the received object.
          </para>
          </footnote>. This did not happen in the pre-refactoring code because objects
          were passed as references to their true types.
        </para>
        <para>
          A type is said to be <emphasis>registered</emphasis> into a polymorphic
          collection if there is a (potentially empty) segment created for it. This
          can be checked with:
        </para>
<programlisting><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">is_registered</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">warrior</phrase><phrase role="special">&gt;()&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>       <phrase role="comment">// prints 0</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">is_registered</phrase><phrase role="special">(</phrase><phrase role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase role="identifier">warrior</phrase><phrase role="special">))&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase> <phrase role="comment">// alternate syntax</phrase>
</programlisting>
        <para>
          Registration happens automatically when the object is passed as a reference
          to its true type or <link linkend="poly_collection.tutorial.insertion_and_emplacement.emplacement"><code><phrase
          role="identifier">emplace</phrase></code></link>'d, and explicitly with
          <code><phrase role="identifier">register_types</phrase></code>:
        </para>
<programlisting><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">register_types</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">warrior</phrase><phrase role="special">,</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">,</phrase><phrase role="identifier">goblin</phrase><phrase role="special">&gt;();</phrase>
<phrase role="comment">// everything works fine now</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">;</phrase><phrase role="identifier">i</phrase><phrase role="special">&lt;</phrase><phrase role="number">8</phrase><phrase role="special">;++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(*</phrase><phrase role="identifier">make_sprite</phrase><phrase role="special">());</phrase>
</programlisting>
        <para>
          Once <code><phrase role="identifier">T</phrase></code> has been registered
          into a polymorphic collection, it remains so regardless of whether objects
          of type <code><phrase role="identifier">T</phrase></code> are stored or
          not, except if the collection is moved from, assigned to, or swapped.
        </para>
        <para>
          As slicing is mainly an issue with OOP, <code><phrase role="identifier">unregistered_type</phrase></code>
          exceptions are expected to be much less frequent with <code><phrase role="identifier">boost</phrase><phrase
          role="special">::</phrase><phrase role="identifier">function_collection</phrase></code>
          and <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">any_collection</phrase></code>. Contrived examples can
          be found, though:
        </para>
<programlisting><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">renderable</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">c1</phrase><phrase role="special">,</phrase><phrase role="identifier">c2</phrase><phrase role="special">;</phrase>
<phrase role="special">...</phrase> <phrase role="comment">// populate c2</phrase>

<phrase role="identifier">c1</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(*</phrase><phrase role="identifier">c2</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">());</phrase> <phrase role="comment">// throws: actual type of *c2.begin() not known by c1</phrase>
</programlisting>
      </section>
      <section id="poly_collection.tutorial.deeper_into_the_segmented_nature.segment_specific_interface">
        <title><link linkend="poly_collection.tutorial.deeper_into_the_segmented_nature.segment_specific_interface">Segment-specific
        interface</link></title>
        <para>
          For most of the interface of a polymorphic collection, it is possible to
          only address the elements of a given segment by providing either their
          type or <code><phrase role="keyword">typeid</phrase><phrase role="special">()</phrase></code>.
          For instance:
        </para>
<programlisting><phrase role="special">...</phrase> <phrase role="comment">// populate c with 8 assorted entities</phrase>

<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">()&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>                    <phrase role="comment">// 8 sprites</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">&gt;()&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>        <phrase role="comment">// 2 juggernauts</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">(</phrase><phrase role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">))&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>  <phrase role="comment">// alternate syntax</phrase>
<phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">clear</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">&gt;();</phrase>                        <phrase role="comment">// remove juggenauts only</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">empty</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">&gt;()&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>       <phrase role="comment">// 1 (no juggernauts left)</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">()&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>                    <phrase role="comment">// 6 sprites remaining</phrase>
</programlisting>
        <para>
          Note that any of these (except <link linkend="poly_collection.tutorial.deeper_into_the_segmented_nature.reserve"><code><phrase
          role="identifier">reserve</phrase></code></link>) will throw <code><phrase
          role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase
          role="identifier">unregistered_type</phrase></code> if the type is not
          registered. Segment-specific addressability also includes traversal:
        </para>
      </section>
      <section id="poly_collection.tutorial.deeper_into_the_segmented_nature.local_iterators">
        <title><link linkend="poly_collection.tutorial.deeper_into_the_segmented_nature.local_iterators">Local
        iterators</link></title>
        <para>
          The following runs only over the <code><phrase role="identifier">warrior</phrase></code>s
          of the collection:
        </para>
<programlisting><phrase role="keyword">const</phrase> <phrase role="keyword">char</phrase><phrase role="special">*</phrase> <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;&quot;</phrase><phrase role="special">;</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">auto</phrase> <phrase role="identifier">first</phrase><phrase role="special">=</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase role="identifier">warrior</phrase><phrase role="special">)),</phrase><phrase role="identifier">last</phrase><phrase role="special">=</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(</phrase><phrase role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase role="identifier">warrior</phrase><phrase role="special">));</phrase>
    <phrase role="identifier">first</phrase><phrase role="special">!=</phrase><phrase role="identifier">last</phrase><phrase role="special">;++</phrase><phrase role="identifier">first</phrase><phrase role="special">){</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">comma</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">first</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">render</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">);</phrase>
  <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;,&quot;</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          Output:
        </para>
<programlisting>warrior 2,warrior 6
</programlisting>
        <para>
          <code><phrase role="identifier">begin</phrase><phrase role="special">|</phrase><phrase
          role="identifier">end</phrase><phrase role="special">(</phrase><phrase
          role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase
          role="identifier">T</phrase><phrase role="special">))</phrase></code> return
          objects of type <code><phrase role="identifier">local_base_iterator</phrase></code>
          associated to the segment for <code><phrase role="identifier">T</phrase></code>.
          These iterators dereference to the same value as regular iterators (in
          the case of <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">base</phrase><phrase role="special">&gt;</phrase></code>,
          <code><phrase role="identifier">base</phrase><phrase role="special">&amp;</phrase></code>)
          but can only be used to traverse a given segment (for instance, <code><phrase
          role="identifier">local_base_iterator</phrase></code>'s from different
          segments cannot be compared between them). In exchange, <code><phrase role="identifier">local_base_iterator</phrase></code>
          is a <ulink url="http://en.cppreference.com/w/cpp/concept/RandomAccessIterator"><emphasis
          role="bold"><code><phrase role="identifier">RandomAccessIterator</phrase></code></emphasis></ulink>,
          whereas whole-collection iterators only model <ulink url="http://en.cppreference.com/w/cpp/concept/ForwardIterator"><emphasis
          role="bold"><code><phrase role="identifier">ForwardIterator</phrase></code></emphasis></ulink>.
        </para>
        <para>
          Even more powerful than <code><phrase role="identifier">local_base_iterator</phrase></code>
          is <code><phrase role="identifier">local_iterator</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">T</phrase><phrase role="special">&gt;</phrase></code>:
        </para>
<programlisting><phrase role="keyword">const</phrase> <phrase role="keyword">char</phrase><phrase role="special">*</phrase> <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;&quot;</phrase><phrase role="special">;</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">auto</phrase> <phrase role="identifier">first</phrase><phrase role="special">=</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">warrior</phrase><phrase role="special">&gt;(),</phrase><phrase role="identifier">last</phrase><phrase role="special">=</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">warrior</phrase><phrase role="special">&gt;();</phrase>
    <phrase role="identifier">first</phrase><phrase role="special">!=</phrase><phrase role="identifier">last</phrase><phrase role="special">;++</phrase><phrase role="identifier">first</phrase><phrase role="special">){</phrase>
  <phrase role="identifier">first</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">rank</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="number">0</phrase><phrase role="special">,</phrase><phrase role="string">&quot;super&quot;</phrase><phrase role="special">);</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">comma</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">first</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">render</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">);</phrase>
  <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;,&quot;</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          This changes the <code><phrase role="identifier">rank</phrase></code> data
          member of existing warriors to append it a <code><phrase role="string">&quot;super&quot;</phrase></code>
          prefix:
        </para>
<programlisting>superwarrior 2,superwarrior 6
</programlisting>
        <para>
          The observant reader will have noticed that in order to access <code><phrase
          role="identifier">rank</phrase></code>, which is a member of <code><phrase
          role="identifier">warrior</phrase></code> rather than its base class <code><phrase
          role="identifier">sprite</phrase></code>, we need <code><phrase role="identifier">first</phrase></code>
          to dereference to <code><phrase role="identifier">warrior</phrase><phrase
          role="special">&amp;</phrase></code>, and this is precisely the difference
          between <code><phrase role="identifier">local_iterator</phrase><phrase
          role="special">&lt;</phrase><phrase role="identifier">warrior</phrase><phrase
          role="special">&gt;</phrase></code> (the type returned by <code><phrase
          role="identifier">begin</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">warrior</phrase><phrase role="special">&gt;()</phrase></code>)
          and <code><phrase role="identifier">local_base_iterator</phrase></code>.
          <code><phrase role="identifier">local_iterator</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">warrior</phrase><phrase role="special">&gt;</phrase></code>
          is also a <ulink url="http://en.cppreference.com/w/cpp/concept/RandomAccessIterator"><emphasis
          role="bold"><code><phrase role="identifier">RandomAccessIterator</phrase></code></emphasis></ulink>:
          for most respects, [<code><phrase role="identifier">begin</phrase><phrase
          role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase
          role="special">&gt;()</phrase></code>, <code><phrase role="identifier">end</phrase><phrase
          role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase
          role="special">&gt;()</phrase></code>) can be regarded as a range over
          an array of <code><phrase role="identifier">T</phrase></code> objects.
          <code><phrase role="identifier">local_iterator</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">T</phrase><phrase role="special">&gt;</phrase></code>s
          can be explicitly converted to <code><phrase role="identifier">local_base_iterator</phrase></code>s.
          Conversely, if a <code><phrase role="identifier">local_base_iterator</phrase></code>
          is associated to a segment for <code><phrase role="identifier">T</phrase></code>,
          it can then be explictly converted to a <code><phrase role="identifier">local_iterator</phrase><phrase
          role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase
          role="special">&gt;</phrase></code> (otherwise the conversion is undefined
          behavior).
        </para>
        <para>
          The figure shows the action scopes of all the iterators associated to a
          polymorphic collection (<code><phrase role="identifier">const_</phrase></code>
          versions not included):
        </para>
        <para>
          <inlinemediaobject><imageobject><imagedata fileref="img/poly_collection_iterators.png"></imagedata></imageobject></inlinemediaobject>
        </para>
        <para>
          We have yet to describe the bottom part of the diagram. To allow for per-segment
          traversal of a polymorphic collection, a <code><phrase role="identifier">segment_traversal</phrase></code>
          member function is provided that returns an object <code><phrase role="identifier">s</phrase></code>
          of type <code><phrase role="identifier">segment_traversal_info</phrase></code>
          such that [<code><phrase role="identifier">s</phrase><phrase role="special">.</phrase><phrase
          role="identifier">begin</phrase><phrase role="special">()</phrase></code>,
          <code><phrase role="identifier">s</phrase><phrase role="special">.</phrase><phrase
          role="identifier">end</phrase><phrase role="special">()</phrase></code>)
          ranges over <code><phrase role="identifier">segment_info</phrase></code>
          objects associated to corresponding segments of the collection. Each <code><phrase
          role="identifier">segment_info</phrase></code> has <code><phrase role="identifier">begin</phrase></code>
          and <code><phrase role="identifier">end</phrase></code> member functions
          returning <code><phrase role="identifier">local_base_iterator</phrase></code>s
          that span over the segment. Complicated as it may seem, this just enables
          us to write nested segment-element <code><phrase role="keyword">for</phrase></code>-loops
          like the following:
        </para>
<programlisting><phrase role="keyword">const</phrase> <phrase role="keyword">char</phrase><phrase role="special">*</phrase> <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;&quot;</phrase><phrase role="special">;</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">auto</phrase> <phrase role="identifier">seg_info</phrase><phrase role="special">:</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">segment_traversal</phrase><phrase role="special">()){</phrase>
  <phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="identifier">sprite</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">s</phrase><phrase role="special">:</phrase><phrase role="identifier">seg_info</phrase><phrase role="special">){</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">comma</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">s</phrase><phrase role="special">.</phrase><phrase role="identifier">render</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;,&quot;</phrase><phrase role="special">;</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">}</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          Segment decomposition of traversal loops forms the basis of <link linkend="poly_collection.tutorial.algorithms">improved-performance
          algorithms</link>.
        </para>
      </section>
      <section id="poly_collection.tutorial.deeper_into_the_segmented_nature.reserve">
        <title><link linkend="poly_collection.tutorial.deeper_into_the_segmented_nature.reserve">Reserve</link></title>
        <para>
          Much like <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
          role="identifier">vector</phrase></code>, segments can be made to reserve
          memory in advance to minimize reallocations:
        </para>
<programlisting><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">reserve</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">goblin</phrase><phrase role="special">&gt;(</phrase><phrase role="number">100</phrase><phrase role="special">);</phrase> <phrase role="comment">// no reallocation till we exceed 100 goblins</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">capacity</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">goblin</phrase><phrase role="special">&gt;()&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase> <phrase role="comment">// prints 100</phrase>
</programlisting>
        <para>
          If there is no segment for the indicated type (here, <code><phrase role="identifier">goblin</phrase></code>),
          one is automatically created. This is in contrast with the rest of segment-specific
          member functions, which throw <link linkend="poly_collection.tutorial.deeper_into_the_segmented_nature.type_registration"><code><phrase
          role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase
          role="identifier">unregistered_type</phrase></code></link>.
        </para>
        <para>
          <code><phrase role="identifier">reserve</phrase></code> can deal with all
          segments at once. The following
        </para>
<programlisting><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase role="number">1000</phrase><phrase role="special">);</phrase> <phrase role="comment">// reserve(1000) for each segment</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">capacity</phrase><phrase role="special">()&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase> <phrase role="comment">// prints 1000</phrase>
</programlisting>
        <para>
          instructs every <emphasis>existing</emphasis> segment to reserve 1,000
          elements. If a segment is created later (through element insertion or with
          <link linkend="poly_collection.tutorial.deeper_into_the_segmented_nature.type_registration">type
          registration</link>), its capacity will be different.
        </para>
        <para>
          <code><phrase role="identifier">capacity</phrase><phrase role="special">()</phrase></code>,
          without further type indication, returns the <emphasis>minimum</emphasis>
          capacity across all existing segments. This can lead to some curious behavior:
        </para>
<programlisting><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">sprite</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">c</phrase><phrase role="special">;</phrase> <phrase role="comment">// newly created collection</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">capacity</phrase><phrase role="special">()&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase> <phrase role="comment">// prints 18446744073709551615!!</phrase>
</programlisting>
        <para>
          The above makes perfect (mathematical) sense: as a newly created collection
          has no segments and <ulink url="https://en.wikipedia.org/wiki/Empty_set#Extended_real_numbers">the
          minimum of the empty set is conventionally defined as ∞</ulink>, the
          value returned is the closest we have to infinity, i.e. <ulink url="http://en.cppreference.com/w/cpp/types/numeric_limits/max"><code><phrase
          role="identifier">std</phrase><phrase role="special">::</phrase><phrase
          role="identifier">numeric_limits</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">size_type</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">max</phrase><phrase role="special">()</phrase></code></ulink>.
          Once there is at least one segment, the capacity of the collection drops
          to more mundane values:
        </para>
<programlisting><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">register_types</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">warrior</phrase><phrase role="special">,</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">,</phrase><phrase role="identifier">goblin</phrase><phrase role="special">&gt;();</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">capacity</phrase><phrase role="special">()&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase> <phrase role="comment">// prints 0</phrase>
</programlisting>
      </section>
    </section>
    <section id="poly_collection.tutorial.insertion_and_emplacement">
      <title><link linkend="poly_collection.tutorial.insertion_and_emplacement">Insertion
      and emplacement</link></title>
      <para>
        (Code samples from <ulink url="../../example/insertion_emplacement.cpp"><code><phrase
        role="identifier">insertion_emplacement</phrase><phrase role="special">.</phrase><phrase
        role="identifier">cpp</phrase></code></ulink>.)
      </para>
      <para>
        We already know that <code><phrase role="identifier">insert</phrase><phrase
        role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">)</phrase></code>,
        without further positional information, stores <code><phrase role="identifier">x</phrase></code>
        at the end of its associated segment. When a regular iterator <code><phrase
        role="identifier">it</phrase></code> is provided, insertion happens at the
        position indicated if both <code><phrase role="identifier">it</phrase></code>
        and <code><phrase role="identifier">x</phrase></code> belong in the same
        segment; otherwise, <code><phrase role="identifier">it</phrase></code> is
        ignored. For instance, if our sprite collection has the following entities:
      </para>
<programlisting>juggernaut 0,juggernaut 4,juggernaut 7,goblin 1,goblin 3,goblin 5,warrior 2,warrior 6
</programlisting>
      <para>
        then this code:
      </para>
<programlisting><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">{</phrase><phrase role="number">8</phrase><phrase role="special">});</phrase>
</programlisting>
      <para>
        puts the new <code><phrase role="identifier">juggernaut</phrase></code> at
        the beginning:
      </para>
<programlisting><phrase role="red">juggernaut 8</phrase>,juggernaut 0,juggernaut 4,juggernaut 7,goblin 1,...
</programlisting>
      <para>
        whereas the position hint at
      </para>
<programlisting><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier">goblin</phrase><phrase role="special">{</phrase><phrase role="number">9</phrase><phrase role="special">});</phrase>
</programlisting>
      <para>
        is ignored and the new <code><phrase role="identifier">goblin</phrase></code>
        gets inserted at the end of its segment:
      </para>
<programlisting>juggernaut 8,...,juggernaut 7,goblin 1,goblin 3,goblin 5,<phrase role="red">goblin 9</phrase>,warrior 2,...
</programlisting>
      <para>
        <link linkend="poly_collection.tutorial.deeper_into_the_segmented_nature.local_iterators">Local
        iterators</link> can also be used to indicate the insertion position:
      </para>
<programlisting><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">&gt;()+</phrase><phrase role="number">2</phrase><phrase role="special">,</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">{</phrase><phrase role="number">10</phrase><phrase role="special">});</phrase>
                           <phrase role="comment">// ^^ remember local iterators are random access</phrase>
</programlisting>
<programlisting>juggernaut 8,juggernaut 0,<phrase role="red">juggernaut 10</phrase>,juggernaut 4,juggernaut 7,goblin 1,...
</programlisting>
      <para>
        There is a caveat, though: when using a local iterator, the element inserted
        <emphasis>must belong to the indicated segment</emphasis>:
      </para>
<programlisting><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase role="identifier">warrior</phrase><phrase role="special">)),</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">{</phrase><phrase role="number">11</phrase><phrase role="special">});</phrase> <phrase role="comment">// undefined behavior!!</phrase>
</programlisting>
      <para>
        Member functions are provided for range insertion, with and without a position
        hint:
      </para>
<programlisting><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">sprite</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">c2</phrase><phrase role="special">;</phrase>

<phrase role="identifier">c2</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">());</phrase> <phrase role="comment">// read below</phrase>

<phrase role="comment">// add some more warriors</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">array</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">warrior</phrase><phrase role="special">,</phrase><phrase role="number">3</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">aw</phrase><phrase role="special">={{</phrase><phrase role="number">11</phrase><phrase role="special">,</phrase><phrase role="number">12</phrase><phrase role="special">,</phrase><phrase role="number">13</phrase><phrase role="special">}};</phrase>
<phrase role="identifier">c2</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">aw</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier">aw</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">());</phrase>

<phrase role="comment">// add some goblins at the beginning of their segment</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">array</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">goblin</phrase><phrase role="special">,</phrase><phrase role="number">3</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">ag</phrase><phrase role="special">={{</phrase><phrase role="number">14</phrase><phrase role="special">,</phrase><phrase role="number">15</phrase><phrase role="special">,</phrase><phrase role="number">16</phrase><phrase role="special">}};</phrase>
<phrase role="identifier">c2</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">c2</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">goblin</phrase><phrase role="special">&gt;(),</phrase><phrase role="identifier">ag</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier">ag</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">());</phrase>
</programlisting>
      <para>
        As <link linkend="poly_collection.tutorial.deeper_into_the_segmented_nature.type_registration">already
        explained</link>, care must be taken that types be pre-registered into the
        collection if they are not passed as references to their actual type. So,
        why did not this line
      </para>
<programlisting><phrase role="identifier">c2</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">());</phrase>
</programlisting>
      <para>
        throw <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase
        role="identifier">unregistered_type</phrase></code>? As it happens, in the
        special case where the inserted range belongs to a polymorphic collection
        of the same type, registration is done automatically <footnote id="poly_collection.tutorial.insertion_and_emplacement.f0">
        <para>
          That is, Boost.PolyCollection has enough static information to do type
          registration without further assistance from the user.
        </para>
        </footnote>.
      </para>
      <para>
        <anchor id="poly_collection.tutorial.insertion_and_emplacement.emplacement"/>Emplacement
        is slightly different for Boost.PolyCollection than with standard containers.
        Consider this attempt at emplacing a <code><phrase role="identifier">goblin</phrase></code>:
      </para>
<programlisting><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">emplace</phrase><phrase role="special">(</phrase><phrase role="number">11</phrase><phrase role="special">);</phrase> <phrase role="comment">// does not compile</phrase>
</programlisting>
      <para>
        If considered carefully, it is only natural that the code above not compile:
        Boost.PolyCollection cannot possibly know that it is precisely a <code><phrase
        role="identifier">goblin</phrase></code> that we want to emplace and not
        some other type constructible from an <code><phrase role="keyword">int</phrase></code>
        (like <code><phrase role="identifier">warrior</phrase></code>, <code><phrase
        role="identifier">juggernaut</phrase></code> or an unrelated class). So,
        the type of the emplaced element has to be specified explicitly:
      </para>
<programlisting><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">emplace</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">goblin</phrase><phrase role="special">&gt;(</phrase><phrase role="number">11</phrase><phrase role="special">);</phrase> <phrase role="comment">// now it works</phrase>
</programlisting>
      <para>
        As with <code><phrase role="identifier">insert</phrase></code>, a position
        can be indicated for emplacing:
      </para>
<programlisting><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">emplace_hint</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="number">12</phrase><phrase role="special">);</phrase> <phrase role="comment">// at the beginning if possible</phrase>
<phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">emplace_pos</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">goblin</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">goblin</phrase><phrase role="special">&gt;()+</phrase><phrase role="number">2</phrase><phrase role="special">,</phrase><phrase role="number">13</phrase><phrase role="special">);</phrase> <phrase role="comment">// amidst the goblins</phrase>
<phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">emplace_pos</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">warrior</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase role="identifier">warrior</phrase><phrase role="special">)),</phrase><phrase role="number">14</phrase><phrase role="special">);</phrase> <phrase role="comment">// local_base_iterator</phrase>
</programlisting>
      <para>
        Note the naming here: <code><phrase role="identifier">emplace_hint</phrase></code>
        is used when the position is indicated with a regular iterator, and for local
        iterators it is <code><phrase role="identifier">emplace_pos</phrase></code>.
      </para>
    </section>
    <section id="poly_collection.tutorial.exceptions">
      <title><link linkend="poly_collection.tutorial.exceptions">Exceptions</link></title>
      <para>
        (Code samples from <ulink url="../../example/exceptions.cpp"><code><phrase
        role="identifier">exceptions</phrase><phrase role="special">.</phrase><phrase
        role="identifier">cpp</phrase></code></ulink>.)
      </para>
      <para>
        Besides the usual exceptions like <ulink url="http://en.cppreference.com/w/cpp/memory/new/bad_alloc"><code><phrase
        role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">bad_alloc</phrase></code></ulink>
        and those generated by user-provided types, polymorphic collections can throw
        the following:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
            role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase
            role="identifier">unregistered_type</phrase></code>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
            role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase
            role="identifier">not_copy_constructible</phrase></code>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
            role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase
            role="identifier">not_equality_comparable</phrase></code>
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        The situations in which the first is raised have been <link linkend="poly_collection.tutorial.deeper_into_the_segmented_nature.type_registration">already
        discussed</link>; let us focus on the other two.
      </para>
      <para>
        We have a new type of sprite in our role game defined by the non-copyable
        class <code><phrase role="identifier">elf</phrase></code>:
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">elf</phrase><phrase role="special">:</phrase><phrase role="identifier">sprite</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">sprite</phrase><phrase role="special">::</phrase><phrase role="identifier">sprite</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">elf</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">elf</phrase><phrase role="special">&amp;)=</phrase><phrase role="keyword">delete</phrase><phrase role="special">;</phrase> <phrase role="comment">// not copyable</phrase>
  <phrase role="identifier">elf</phrase><phrase role="special">(</phrase><phrase role="identifier">elf</phrase><phrase role="special">&amp;&amp;)=</phrase><phrase role="keyword">default</phrase><phrase role="special">;</phrase>     <phrase role="comment">// but moveable</phrase>
  <phrase role="keyword">virtual</phrase> <phrase role="keyword">void</phrase> <phrase role="identifier">render</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">os</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">{</phrase><phrase role="identifier">os</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;elf &quot;</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">id</phrase><phrase role="special">;};</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        and we use it without problems until we write this:
      </para>
<programlisting><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">elf</phrase><phrase role="special">{</phrase><phrase role="number">0</phrase><phrase role="special">});</phrase> <phrase role="comment">// no problem</phrase>
<phrase role="special">...</phrase>

<phrase role="identifier">c2</phrase><phrase role="special">=</phrase><phrase role="identifier">c</phrase><phrase role="special">;</phrase> <phrase role="comment">// throws boost::poly_collection::not_copy_constructible</phrase>
</programlisting>
      <para>
        The first insertion works because the <code><phrase role="identifier">elf</phrase></code>
        object passed is <emphasis>temporary</emphasis> and can be <emphasis>moved</emphasis>
        into the container, but the second statement actually needs to <emphasis>copy</emphasis>
        the <code><phrase role="identifier">elf</phrase></code> elements in <code><phrase
        role="identifier">c</phrase></code> to <code><phrase role="identifier">c2</phrase></code>,
        hence the exception.
      </para>
      <para>
        The potentially surprising aspect of this behavior is that standard containers
        signal this kind of problems by <emphasis>failing at compile time</emphasis>.
        Here we cannot afford this luxury because the exact types contained in a
        polymorphic collection are not known until run time (for instance, if <code><phrase
        role="identifier">elf</phrase></code> elements had been erased before copying
        <code><phrase role="identifier">c</phrase></code> to <code><phrase role="identifier">c2</phrase></code>
        everything would have worked): basically, the deferral of errors from compile
        time to run time is an intrinsic feature of dynamic polymorphism.
      </para>
      <para>
        In the same vein, equality comparison requires that elements themselves be
        equality comparable:
      </para>
<programlisting><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">clear</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">elf</phrase><phrase role="special">&gt;();</phrase> <phrase role="comment">// get rid of non-copyable elfs</phrase>
<phrase role="identifier">c2</phrase><phrase role="special">=</phrase><phrase role="identifier">c</phrase><phrase role="special">;</phrase>           <phrase role="comment">// now it works</phrase>
<phrase role="comment">// check that the two are indeed equal</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;(</phrase><phrase role="identifier">c</phrase><phrase role="special">==</phrase><phrase role="identifier">c2</phrase><phrase role="special">)&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
                <phrase role="comment">// throws boost::poly_collection::not_equality_comparable</phrase>
</programlisting>
      <para>
        The above is unremarkable once we notice we have not defined <code><phrase
        role="keyword">operator</phrase><phrase role="special">==</phrase></code>
        for any <code><phrase role="identifier">sprite</phrase></code>. The problem
        may go unnoticed for quite some time, however, because determining that two
        polymorphic collections are equal (i.e. all their non-empty segments are
        equal) can return <code><phrase role="keyword">false</phrase></code> without
        comparing anything at all (for instance, if segment sizes differ), in which
        case no exception is thrown.
      </para>
      <para>
        These three are all the intrinsic exceptions thrown by Boost.PolyCollection.
        The implication is that if a type is <ulink url="http://en.cppreference.com/w/cpp/concept/CopyConstructible"><emphasis
        role="bold"><code><phrase role="identifier">CopyConstructible</phrase></code></emphasis></ulink>,
        <ulink url="http://en.cppreference.com/w/cpp/concept/MoveAssignable"><emphasis
        role="bold"><code><phrase role="identifier">MoveAssignable</phrase></code></emphasis></ulink>
        (or move construction does not throw) and <ulink url="http://en.cppreference.com/w/cpp/concept/EqualityComparable"><emphasis
        role="bold"><code><phrase role="identifier">EqualityComparable</phrase></code></emphasis></ulink>,
        then the entire interface of Boost.PolyCollection is unrestrictedly available
        for it <footnote id="poly_collection.tutorial.exceptions.f0">
        <para>
          Provided, of course, that the type has the <emphasis>right</emphasis> to
          be in the collection, that is, it is derived from the specified base, or
          callable with the specified signature, etc.
        </para>
        </footnote>.
      </para>
    </section>
    <section id="poly_collection.tutorial.algorithms">
      <title><link linkend="poly_collection.tutorial.algorithms">Algorithms</link></title>
      <para>
        (Code samples from <ulink url="../../example/algorithms.cpp"><code><phrase
        role="identifier">algorithms</phrase><phrase role="special">.</phrase><phrase
        role="identifier">cpp</phrase></code></ulink>.)
      </para>
      <para>
        The ultimate purpose of Boost.PolyCollection is to speed up the processing
        of large quantities of polymorphic entities, in particular for those operations
        that involve linear traversal as implemented with a <code><phrase role="keyword">for</phrase></code>-loop
        or using the quintessential <ulink url="http://en.cppreference.com/w/cpp/algorithm/for_each"><code><phrase
        role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">for_each</phrase></code></ulink>
        algorithm.
      </para>
<programlisting><phrase role="keyword">const</phrase> <phrase role="keyword">char</phrase><phrase role="special">*</phrase> <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;&quot;</phrase><phrase role="special">;</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">for_each</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),[&amp;](</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">sprite</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">s</phrase><phrase role="special">){</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">comma</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">s</phrase><phrase role="special">.</phrase><phrase role="identifier">render</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">);</phrase>
  <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;,&quot;</phrase><phrase role="special">;</phrase>
<phrase role="special">});</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
</programlisting>
      <para>
        Replacing the container used in the program from classic alternatives to
        Boost.PolyCollection:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
            role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">base</phrase><phrase role="special">*&gt;</phrase></code>
            (or similar) → <code><phrase role="identifier">boost</phrase><phrase
            role="special">::</phrase><phrase role="identifier">base_collection</phrase><phrase
            role="special">&lt;</phrase><phrase role="identifier">base</phrase><phrase
            role="special">&gt;</phrase></code>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
            role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">std</phrase><phrase role="special">::</phrase><phrase
            role="identifier">function</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">signature</phrase><phrase role="special">&gt;&gt;</phrase></code>
            → <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
            role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">signature</phrase><phrase role="special">&gt;</phrase></code>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
            role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
            role="identifier">type_erasure</phrase><phrase role="special">::</phrase><phrase
            role="identifier">any</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">concept</phrase><phrase role="special">&gt;&gt;</phrase></code>
            → <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
            role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">concept</phrase><phrase role="special">&gt;</phrase></code>
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        is expected to increase performance due to better caching and branch prediction
        behavior. But there is still room for improvement.
      </para>
      <para>
        Consider this transformation of the code above using a double segment-element
        loop (based on the <link linkend="poly_collection.tutorial.deeper_into_the_segmented_nature.local_iterators">local
        iterator</link> capabilities of Boost.PolyCollection):
      </para>
<programlisting><phrase role="keyword">const</phrase> <phrase role="keyword">char</phrase><phrase role="special">*</phrase> <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;&quot;</phrase><phrase role="special">;</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">auto</phrase> <phrase role="identifier">seg_info</phrase><phrase role="special">:</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">segment_traversal</phrase><phrase role="special">()){</phrase>
  <phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">sprite</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">s</phrase><phrase role="special">:</phrase><phrase role="identifier">seg_info</phrase><phrase role="special">){</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">comma</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">s</phrase><phrase role="special">.</phrase><phrase role="identifier">render</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;,&quot;</phrase><phrase role="special">;</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
</programlisting>
      <para>
        Although not obvious at first sight, this version of the same basic operation
        is actually <emphasis>faster</emphasis> than the first one: for a segmented
        structure such as used by Boost.PolyCollection, each iteration with the non-local
        iterator passed to <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
        role="identifier">for_each</phrase></code> involves:
      </para>
      <orderedlist>
        <listitem>
          <simpara>
            hopping to next position in the segment,
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            checking for <emphasis>end of segment</emphasis> (always),
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            if at end (infrequent), selecting the next segment,
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            checking for <emphasis>end of range</emphasis> (always),
          </simpara>
        </listitem>
      </orderedlist>
      <para>
        whereas in the second version, iteration on the inner loop, where most processing
        happens, is a simple increment-and-check operation, that is, there is one
        less check (which happens at the much shorter outer loop). When the workload
        of the algorithm (the actually useful stuff done with the elements themselves)
        is relatively light, the overhead of looping can be very significant.
      </para>
      <para>
        To make it easier for the user to take advantage of faster segment-element
        looping, Boost.PolyCollection provides its own version of <code><phrase role="identifier">for_each</phrase></code>
        based on that technique:
      </para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">poly_collection</phrase><phrase role="special">/</phrase><phrase role="identifier">algorithm</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="special">...</phrase>

<phrase role="keyword">const</phrase> <phrase role="keyword">char</phrase><phrase role="special">*</phrase> <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;&quot;</phrase><phrase role="special">;</phrase>
<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase role="identifier">for_each</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),[&amp;](</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">sprite</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">s</phrase><phrase role="special">){</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">comma</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">s</phrase><phrase role="special">.</phrase><phrase role="identifier">render</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">);</phrase>
  <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;,&quot;</phrase><phrase role="special">;</phrase>
<phrase role="special">});</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
</programlisting>
      <para>
        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase
        role="identifier">for_each</phrase></code> has the same interface and behavior
        as <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
        role="identifier">for_each</phrase></code> except for the fact that it only
        works for (non-local) iterators of a polymorphic container <footnote id="poly_collection.tutorial.algorithms.f0">
        <para>
          For any other type of iterator, it is guaranteed not to compile.
        </para>
        </footnote>. Versions of other standard algorithms are provided as well:
      </para>
<programlisting><phrase role="keyword">auto</phrase> <phrase role="identifier">n</phrase><phrase role="special">=</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase role="identifier">count_if</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),[](</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">sprite</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">s</phrase><phrase role="special">){</phrase><phrase role="keyword">return</phrase> <phrase role="identifier">s</phrase><phrase role="special">.</phrase><phrase role="identifier">id</phrase><phrase role="special">%</phrase><phrase role="number">2</phrase><phrase role="special">==</phrase><phrase role="number">0</phrase><phrase role="special">;});</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">n</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot; sprites with even id\n&quot;</phrase><phrase role="special">;</phrase>
</programlisting>
      <para>
        In fact, variants are given of most (though not all) of the algorithms in
        <ulink url="http://en.cppreference.com/w/cpp/algorithm"><code><phrase role="special">&lt;</phrase><phrase
        role="identifier">algorithm</phrase><phrase role="special">&gt;</phrase></code></ulink>
        among those that are compatible with polymorphic collections <footnote id="poly_collection.tutorial.algorithms.f1">
        <para>
          For example, algorithms requiring bidrectional iterators or a higher category
          are not provided because polymorphic collections have forward-only iterators.
        </para>
        </footnote>. Check the <link linkend="poly_collection.reference.header_boost_poly_collection_alg">reference</link>
        for details.
      </para>
      <section id="poly_collection.tutorial.algorithms.type_restitution">
        <title><link linkend="poly_collection.tutorial.algorithms.type_restitution">Type
        restitution</link></title>
        <para>
          By <emphasis>type restitution</emphasis> we mean the generic process of
          getting a concrete entity from an abstract one by providing missing type
          information:
        </para>
<programlisting><phrase role="identifier">sprite</phrase><phrase role="special">*</phrase>  <phrase role="identifier">ps</phrase><phrase role="special">=</phrase><phrase role="keyword">new</phrase> <phrase role="identifier">warrior</phrase><phrase role="special">{</phrase><phrase role="number">5</phrase><phrase role="special">};</phrase>
<phrase role="comment">// sprite -&gt; warrior</phrase>
<phrase role="identifier">warrior</phrase><phrase role="special">*</phrase> <phrase role="identifier">pw</phrase><phrase role="special">=</phrase><phrase role="keyword">static_cast</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">warrior</phrase><phrase role="special">*&gt;(</phrase><phrase role="identifier">ps</phrase><phrase role="special">);</phrase>

<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">type_erasure</phrase><phrase role="special">::</phrase><phrase role="identifier">any</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">renderable</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">r</phrase><phrase role="special">=</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">{</phrase><phrase role="string">&quot;hello&quot;</phrase><phrase role="special">};</phrase>
<phrase role="comment">// renderable -&gt; std::string</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">str</phrase><phrase role="special">=</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">type_erasure</phrase><phrase role="special">::</phrase><phrase role="identifier">any_cast</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">&amp;&gt;(</phrase><phrase role="identifier">r</phrase><phrase role="special">);</phrase>
</programlisting>
        <para>
          Type restitution has the potential to increase performance. Consider for
          instance the following:
        </para>
<programlisting><phrase role="comment">// render r with std::string restitution</phrase>
<phrase role="keyword">if</phrase><phrase role="special">(</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">type_erasure</phrase><phrase role="special">::</phrase><phrase role="identifier">typeid_of</phrase><phrase role="special">(</phrase><phrase role="identifier">r</phrase><phrase role="special">)==</phrase><phrase role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">)){</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">str</phrase><phrase role="special">=</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">type_erasure</phrase><phrase role="special">::</phrase><phrase role="identifier">any_cast</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">&amp;&gt;(</phrase><phrase role="identifier">r</phrase><phrase role="special">);</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">str</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
<phrase role="keyword">else</phrase><phrase role="special">{</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">r</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
        <para>
          Behaviorwise this code is equivalent to simply executing <code><phrase
          role="identifier">std</phrase><phrase role="special">::</phrase><phrase
          role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase
          role="identifier">r</phrase><phrase role="special">&lt;&lt;</phrase><phrase
          role="string">&quot;\n&quot;</phrase></code>, but when type restitution
          succeeds the statement <code><phrase role="identifier">std</phrase><phrase
          role="special">::</phrase><phrase role="identifier">cout</phrase><phrase
          role="special">&lt;&lt;</phrase><phrase role="identifier">str</phrase><phrase
          role="special">&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase></code>
          is skipping a virtual-like call that would have happened if <code><phrase
          role="identifier">r</phrase></code> were used instead. From a general point
          of view, supplying the compiler with extra type information allows it to
          perform more optimizations than in the abstract case, inlining being the
          prime example.
        </para>
        <para>
          All Boost.PolyCollection algorithms accept an optional list of types for
          restitution. Let us use the <link linkend="poly_collection.tutorial.basics.boost_any_collection"><code><phrase
          role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">any_collection</phrase></code></link> scenario to illustrate
          this point:
        </para>
<programlisting><phrase role="keyword">const</phrase> <phrase role="keyword">char</phrase><phrase role="special">*</phrase> <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;&quot;</phrase><phrase role="special">;</phrase>
<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase role="identifier">for_each</phrase>
  <phrase role="special">&lt;</phrase><phrase role="identifier">warrior</phrase><phrase role="special">,</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">,</phrase><phrase role="identifier">goblin</phrase><phrase role="special">,</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">,</phrase><phrase role="identifier">window</phrase><phrase role="special">&gt;(</phrase> <phrase role="comment">//restituted types</phrase>
  <phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),[&amp;](</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">auto</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">){</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">comma</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">x</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;,&quot;</phrase><phrase role="special">;</phrase>
  <phrase role="special">});</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          This rendering loop differs from the non-restituting one in two aspects:
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              A list of types is provided as template arguments to the algorithm.
              This is an indication that the types <emphasis>may</emphasis> be actually
              present in the collection, not a promise. Also, the list of types need
              not be exhaustive, that is, some unlisted types could be present in
              the collection. In general, the more types are restituted, the greater
              the potential improvement in performance.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              The lambda function passed is a generic one accepting its argument
              as <code><phrase role="keyword">const</phrase> <phrase role="keyword">auto</phrase><phrase
              role="special">&amp;</phrase></code> <footnote id="poly_collection.tutorial.algorithms.type_restitution.f0">
              <para>
                This requires C++14, but the same effect can be achieved in C++11
                providing an equivalent, if more cumbersome, functor with a templatized
                call operator.
              </para>
              </footnote>.
            </simpara>
          </listitem>
        </itemizedlist>
        <para>
          Internally, <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase
          role="identifier">for_each</phrase></code> checks for each segment if its
          type, say <code><phrase role="identifier">T</phrase></code>, belongs in
          the type restitution list: if this is the case, the lambda function is
          passed a <code><phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase
          role="special">&amp;</phrase></code> rather than the generic <code><phrase
          role="keyword">const</phrase> <phrase role="identifier">boost</phrase><phrase
          role="special">::</phrase><phrase role="identifier">any_collection</phrase><phrase
          role="special">::</phrase><phrase role="identifier">value_type</phrase><phrase
          role="special">&amp;</phrase></code>. For each restituted type we are saving
          indirection calls and possibly getting inlining optimizations, etc. As
          we see in the <link linkend="poly_collection.performance">performance section</link>,
          the speedup can be very significant.
        </para>
        <para>
          Type restitution works equally for the rest of collections of Boost.PolyCollection.
          When using <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">base_collection</phrase></code>, though, the case of
          improved performance is more tricky:
        </para>
<programlisting><phrase role="keyword">const</phrase> <phrase role="keyword">char</phrase><phrase role="special">*</phrase> <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;&quot;</phrase><phrase role="special">;</phrase>
<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase role="identifier">for_each</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">warrior</phrase><phrase role="special">,</phrase><phrase role="identifier">juggernaut</phrase><phrase role="special">,</phrase><phrase role="identifier">goblin</phrase><phrase role="special">&gt;(</phrase>
  <phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),[&amp;](</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">auto</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">s</phrase><phrase role="special">){</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">comma</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">s</phrase><phrase role="special">.</phrase><phrase role="identifier">render</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">comma</phrase><phrase role="special">=</phrase><phrase role="string">&quot;,&quot;</phrase><phrase role="special">;</phrase>
  <phrase role="special">});</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          The problem here is that, even though the argument to the lambda function
          will be restituted (when appropriate) to <code><phrase role="identifier">warrior</phrase><phrase
          role="special">&amp;</phrase></code>, <code><phrase role="identifier">juggernaut</phrase><phrase
          role="special">&amp;</phrase></code> or <code><phrase role="identifier">goblin</phrase><phrase
          role="special">&amp;</phrase></code>, using it still involves doing a virtual
          function call in <code><phrase role="identifier">s</phrase><phrase role="special">.</phrase><phrase
          role="identifier">render</phrase><phrase role="special">(</phrase><phrase
          role="identifier">std</phrase><phrase role="special">::</phrase><phrase
          role="identifier">cout</phrase><phrase role="special">)</phrase></code>.
          Whether this call is resolved to a non-virtual one depends on the quality
          of implementation of the compiler:
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              If the concrete class is marked as <ulink url="http://en.cppreference.com/w/cpp/language/final"><code><phrase
              role="identifier">final</phrase></code></ulink>, the compiler <emphasis>in
              principle</emphasis> has enough information to get rid of the virtual
              function call.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              Other than this, <ulink url="http://hubicka.blogspot.com.es/2014/01/devirtualization-in-c-part-1.html"><emphasis>devirtualization</emphasis></ulink>
              capabilities <emphasis>may</emphasis> be able to figure out that the
              type restitution scenario is actually casting the element to its true
              type, in which case, again, virtual calls are not needed.
            </simpara>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </section>
  <section id="poly_collection.performance">
    <title><link linkend="poly_collection.performance">Performance</link></title>
    <para>
      (Testing program at <ulink url="../../example/perf.cpp"><code><phrase role="identifier">perf</phrase><phrase
      role="special">.</phrase><phrase role="identifier">cpp</phrase></code></ulink>.)
    </para>
    <para>
      We ran tests to measure the performance of the containers of Boost.PolyCollection
      in two scenarios:
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          Insertion of elements.
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          Linear traversal and processing with <code><phrase role="identifier">std</phrase><phrase
          role="special">::</phrase><phrase role="identifier">for_each</phrase></code>
          and <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase
          role="identifier">for_each</phrase></code> (with and without <link linkend="poly_collection.tutorial.algorithms.type_restitution">type
          restitution</link>).
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      As a comparison baseline we used containers and facilities from the standard
      library and Boost (details below). Tests were run in the following environments:
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          <emphasis role="bold">Visual Studio 2015 x86</emphasis>: Visual C++ 2015
          in 32-bit (x86) release mode, Windows 7 64-bit, Intel Core i5-2520M @2.5GHz
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <emphasis role="bold">Visual Studio 2015 x64</emphasis>: Visual C++ 2015
          in 64-bit (x64) release mode, same machine
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <emphasis role="bold">GCC 5.2 x64</emphasis>: GCC 5.2 release mode, Linux
          64 bit, Intel Core i7-3770K @3.5HGz
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <emphasis role="bold">Clang 3.9 x64</emphasis>: Clang 3.9 release mode,
          Xubuntu 16.04 x64, Intel Core i7-5820 @3.3GHz
        </simpara>
      </listitem>
    </itemizedlist>
    <section id="poly_collection.performance.container_definitions">
      <title><link linkend="poly_collection.performance.container_definitions">Container
      definitions</link></title>
      <section id="poly_collection.performance.container_definitions.boost_base_collection">
        <title><link linkend="poly_collection.performance.container_definitions.boost_base_collection"><code><phrase
        role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">base_collection</phrase></code></link></title>
        <itemizedlist>
          <listitem>
            <simpara>
              Baseline container: <code><phrase role="identifier">ptr_vector</phrase></code>
              = <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
              role="identifier">ptr_vector</phrase><phrase role="special">&lt;</phrase><phrase
              role="identifier">base</phrase><phrase role="special">&gt;</phrase></code>
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              Polymorphic collection: <code><phrase role="identifier">base_collection</phrase></code>
              = <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
              role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase
              role="identifier">base</phrase><phrase role="special">&gt;</phrase></code>
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              Element types: <code><phrase role="identifier">T1</phrase></code> =
              <code><phrase role="identifier">derived1</phrase></code>, <code><phrase
              role="identifier">T2</phrase></code> = <code><phrase role="identifier">derived2</phrase></code>,
              <code><phrase role="identifier">T3</phrase></code> = <code><phrase
              role="identifier">derived3</phrase></code>
            </simpara>
          </listitem>
        </itemizedlist>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">base</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">virtual</phrase> <phrase role="special">~</phrase><phrase role="identifier">base</phrase><phrase role="special">()=</phrase><phrase role="keyword">default</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">virtual</phrase> <phrase role="keyword">int</phrase> <phrase role="keyword">operator</phrase><phrase role="special">()(</phrase><phrase role="keyword">int</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">derived1</phrase> <phrase role="identifier">final</phrase><phrase role="special">:</phrase><phrase role="identifier">base</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">derived1</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">n</phrase><phrase role="special">):</phrase><phrase role="identifier">n</phrase><phrase role="special">{</phrase><phrase role="identifier">n</phrase><phrase role="special">}{}</phrase>
  <phrase role="keyword">virtual</phrase> <phrase role="keyword">int</phrase> <phrase role="keyword">operator</phrase><phrase role="special">()(</phrase><phrase role="keyword">int</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">{</phrase><phrase role="keyword">return</phrase> <phrase role="identifier">n</phrase><phrase role="special">;}</phrase>

  <phrase role="keyword">int</phrase> <phrase role="identifier">n</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">derived2</phrase> <phrase role="identifier">final</phrase><phrase role="special">:</phrase><phrase role="identifier">base</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">derived2</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">n</phrase><phrase role="special">):</phrase><phrase role="identifier">n</phrase><phrase role="special">{</phrase><phrase role="identifier">n</phrase><phrase role="special">}{}</phrase>
  <phrase role="keyword">virtual</phrase> <phrase role="keyword">int</phrase> <phrase role="keyword">operator</phrase><phrase role="special">()(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">{</phrase><phrase role="keyword">return</phrase> <phrase role="identifier">x</phrase><phrase role="special">*</phrase><phrase role="identifier">n</phrase><phrase role="special">;}</phrase>

  <phrase role="keyword">int</phrase> <phrase role="identifier">unused</phrase><phrase role="special">,</phrase><phrase role="identifier">n</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">derived3</phrase> <phrase role="identifier">final</phrase><phrase role="special">:</phrase><phrase role="identifier">base</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">derived3</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">n</phrase><phrase role="special">):</phrase><phrase role="identifier">n</phrase><phrase role="special">{</phrase><phrase role="identifier">n</phrase><phrase role="special">}{}</phrase>
  <phrase role="keyword">virtual</phrase> <phrase role="keyword">int</phrase> <phrase role="keyword">operator</phrase><phrase role="special">()(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">{</phrase><phrase role="keyword">return</phrase> <phrase role="identifier">x</phrase><phrase role="special">*</phrase><phrase role="identifier">x</phrase><phrase role="special">*</phrase><phrase role="identifier">n</phrase><phrase role="special">;}</phrase>

  <phrase role="keyword">int</phrase> <phrase role="identifier">unused</phrase><phrase role="special">,</phrase><phrase role="identifier">n</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      </section>
      <section id="poly_collection.performance.container_definitions.boost_function_collection">
        <title><link linkend="poly_collection.performance.container_definitions.boost_function_collection"><code><phrase
        role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">function_collection</phrase></code></link></title>
        <itemizedlist>
          <listitem>
            <simpara>
              Baseline container: <code><phrase role="identifier">func_vector</phrase></code>
              = <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
              role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase
              role="identifier">std</phrase><phrase role="special">::</phrase><phrase
              role="identifier">function</phrase><phrase role="special">&lt;</phrase><phrase
              role="keyword">int</phrase><phrase role="special">(</phrase><phrase
              role="keyword">int</phrase><phrase role="special">)&gt;&gt;</phrase></code>
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              Polymorphic collection: <code><phrase role="identifier">function_collection</phrase></code>
              = <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
              role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase
              role="keyword">int</phrase><phrase role="special">(</phrase><phrase
              role="keyword">int</phrase><phrase role="special">)&gt;</phrase></code>
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              Element types: <code><phrase role="identifier">T1</phrase></code> =
              <code><phrase role="identifier">concrete1</phrase></code>, <code><phrase
              role="identifier">T2</phrase></code> = <code><phrase role="identifier">concrete2</phrase></code>,
              <code><phrase role="identifier">T3</phrase></code> = <code><phrase
              role="identifier">concrete3</phrase></code>
            </simpara>
          </listitem>
        </itemizedlist>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">concrete1</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">concrete1</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">n</phrase><phrase role="special">):</phrase><phrase role="identifier">n</phrase><phrase role="special">{</phrase><phrase role="identifier">n</phrase><phrase role="special">}{}</phrase>
  <phrase role="keyword">int</phrase> <phrase role="keyword">operator</phrase><phrase role="special">()(</phrase><phrase role="keyword">int</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">{</phrase><phrase role="keyword">return</phrase> <phrase role="identifier">n</phrase><phrase role="special">;}</phrase>

  <phrase role="keyword">int</phrase> <phrase role="identifier">n</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">concrete2</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">concrete2</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">n</phrase><phrase role="special">):</phrase><phrase role="identifier">n</phrase><phrase role="special">{</phrase><phrase role="identifier">n</phrase><phrase role="special">}{}</phrase>
  <phrase role="keyword">int</phrase> <phrase role="keyword">operator</phrase><phrase role="special">()(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">{</phrase><phrase role="keyword">return</phrase> <phrase role="identifier">x</phrase><phrase role="special">*</phrase><phrase role="identifier">n</phrase><phrase role="special">;}</phrase>

  <phrase role="keyword">int</phrase> <phrase role="identifier">unused</phrase><phrase role="special">,</phrase><phrase role="identifier">n</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">concrete3</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">concrete3</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">n</phrase><phrase role="special">):</phrase><phrase role="identifier">n</phrase><phrase role="special">{</phrase><phrase role="identifier">n</phrase><phrase role="special">}{}</phrase>
  <phrase role="keyword">int</phrase> <phrase role="keyword">operator</phrase><phrase role="special">()(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">{</phrase><phrase role="keyword">return</phrase> <phrase role="identifier">x</phrase><phrase role="special">*</phrase><phrase role="identifier">x</phrase><phrase role="special">*</phrase><phrase role="identifier">n</phrase><phrase role="special">;}</phrase>

  <phrase role="keyword">int</phrase> <phrase role="identifier">unused</phrase><phrase role="special">,</phrase><phrase role="identifier">n</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      </section>
      <section id="poly_collection.performance.container_definitions.boost_any_collection">
        <title><link linkend="poly_collection.performance.container_definitions.boost_any_collection"><code><phrase
        role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">any_collection</phrase></code></link></title>
        <itemizedlist>
          <listitem>
            <simpara>
              Baseline container: <code><phrase role="identifier">any_vector</phrase></code>
              = <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
              role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase
              role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
              role="identifier">type_erasure</phrase><phrase role="special">::</phrase><phrase
              role="identifier">any</phrase><phrase role="special">&lt;</phrase><phrase
              role="identifier">concept</phrase><phrase role="special">&gt;&gt;</phrase></code>
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              Polymorphic collection: <code><phrase role="identifier">any_collection</phrase></code>
              = <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
              role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase
              role="identifier">concept</phrase><phrase role="special">&gt;</phrase></code>
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              Element types: <code><phrase role="identifier">T1</phrase></code> =
              <code><phrase role="keyword">int</phrase></code>, <code><phrase role="identifier">T2</phrase></code>
              = <code><phrase role="keyword">double</phrase></code>, <code><phrase
              role="identifier">T3</phrase></code> = <code><phrase role="keyword">char</phrase></code>
            </simpara>
          </listitem>
        </itemizedlist>
<programlisting><phrase role="keyword">using</phrase> <phrase role="identifier">concept</phrase><phrase role="special">=</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">mpl</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase>
  <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">type_erasure</phrase><phrase role="special">::</phrase><phrase role="identifier">copy_constructible</phrase><phrase role="special">&lt;&gt;,</phrase>
  <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">type_erasure</phrase><phrase role="special">::</phrase><phrase role="identifier">relaxed</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">type_erasure</phrase><phrase role="special">::</phrase><phrase role="identifier">typeid_</phrase><phrase role="special">&lt;&gt;,</phrase>
  <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">type_erasure</phrase><phrase role="special">::</phrase><phrase role="identifier">incrementable</phrase><phrase role="special">&lt;&gt;</phrase>
<phrase role="special">&gt;;</phrase>
</programlisting>
      </section>
    </section>
    <section id="poly_collection.performance.insertion_tests">
      <title><link linkend="poly_collection.performance.insertion_tests">Insertion
      tests</link></title>
      <para>
        Tests measure the time taken to insert <emphasis>n</emphasis> elements (<emphasis>n</emphasis>
        between 10<superscript>3</superscript> and 10<superscript>7</superscript>) from a source of values with types following the cyclic
        sequence
      </para>
      <para>
        <code><phrase role="identifier">T1</phrase></code> <code><phrase role="identifier">T1</phrase></code>
        <code><phrase role="identifier">T2</phrase></code> <code><phrase role="identifier">T2</phrase></code>
        <code><phrase role="identifier">T3</phrase></code> <code><phrase role="identifier">T1</phrase></code>
        <code><phrase role="identifier">T1</phrase></code> <code><phrase role="identifier">T2</phrase></code>
        <code><phrase role="identifier">T2</phrase></code> <code><phrase role="identifier">T3</phrase></code>
        ···
      </para>
      <para>
        The figures show resulting times in nanoseconds/element. The horizontal axis
        is logarithmic.
      </para>
      <section id="poly_collection.performance.insertion_tests.results_for_boost_base_collectio">
        <title><link linkend="poly_collection.performance.insertion_tests.results_for_boost_base_collectio">Results
        for <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">base_collection</phrase></code></link></title>
        <section id="poly_collection.performance.insertion_tests.results_for_boost_base_collectio.environment">
          <title><link linkend="poly_collection.performance.insertion_tests.results_for_boost_base_collectio.environment">Visual
          Studio 2015 x86</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/insert_base_vs2015_x86.png"/></imageobject>
  </inlinemediaobject>
</phrase> <phrase
            role="aligncenter"><emphasis role="bold">Insertion, Visual Studio 2015
            x86</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.insertion_tests.results_for_boost_base_collectio.environment0">
          <title><link linkend="poly_collection.performance.insertion_tests.results_for_boost_base_collectio.environment0">Visual
          Studio 2015 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/insert_base_vs2015_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase> <phrase
            role="aligncenter"><emphasis role="bold">Insertion, Visual Studio 2015
            x64</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.insertion_tests.results_for_boost_base_collectio.environment1">
          <title><link linkend="poly_collection.performance.insertion_tests.results_for_boost_base_collectio.environment1">GCC
          5.2 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/insert_base_gcc52_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase> <phrase
            role="aligncenter"><emphasis role="bold">Insertion, GCC 5.2 x64</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.insertion_tests.results_for_boost_base_collectio.environment2">
          <title><link linkend="poly_collection.performance.insertion_tests.results_for_boost_base_collectio.environment2">Clang
          3.9 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/insert_base_clang39_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Insertion, Clang 3.9
            x64</emphasis></phrase>
          </para>
        </section>
      </section>
      <section id="poly_collection.performance.insertion_tests.results_for_boost_function_colle">
        <title><link linkend="poly_collection.performance.insertion_tests.results_for_boost_function_colle">Results
        for <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">function_collection</phrase></code></link></title>
        <section id="poly_collection.performance.insertion_tests.results_for_boost_function_colle.environment">
          <title><link linkend="poly_collection.performance.insertion_tests.results_for_boost_function_colle.environment">Visual
          Studio 2015 x86</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/insert_function_vs2015_x86.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Insertion, Visual Studio
            2015 x86</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.insertion_tests.results_for_boost_function_colle.environment0">
          <title><link linkend="poly_collection.performance.insertion_tests.results_for_boost_function_colle.environment0">Visual
          Studio 2015 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/insert_function_vs2015_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Insertion, Visual Studio
            2015 x64</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.insertion_tests.results_for_boost_function_colle.environment1">
          <title><link linkend="poly_collection.performance.insertion_tests.results_for_boost_function_colle.environment1">GCC
          5.2 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/insert_function_gcc52_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Insertion, GCC 5.2 x64</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.insertion_tests.results_for_boost_function_colle.environment2">
          <title><link linkend="poly_collection.performance.insertion_tests.results_for_boost_function_colle.environment2">Clang
          3.9 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/insert_function_clang39_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Insertion, Clang 3.9
            x64</emphasis></phrase>
          </para>
        </section>
      </section>
      <section id="poly_collection.performance.insertion_tests.results_for_boost_any_collection">
        <title><link linkend="poly_collection.performance.insertion_tests.results_for_boost_any_collection">Results
        for <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">any_collection</phrase></code></link></title>
        <section id="poly_collection.performance.insertion_tests.results_for_boost_any_collection.environment">
          <title><link linkend="poly_collection.performance.insertion_tests.results_for_boost_any_collection.environment">Visual
          Studio 2015 x86</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/insert_any_vs2015_x86.png"/></imageobject>
  </inlinemediaobject>
</phrase> <phrase
            role="aligncenter"><emphasis role="bold">Insertion, Visual Studio 2015
            x86</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.insertion_tests.results_for_boost_any_collection.environment0">
          <title><link linkend="poly_collection.performance.insertion_tests.results_for_boost_any_collection.environment0">Visual
          Studio 2015 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/insert_any_vs2015_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase> <phrase
            role="aligncenter"><emphasis role="bold">Insertion, Visual Studio 2015
            x64</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.insertion_tests.results_for_boost_any_collection.environment1">
          <title><link linkend="poly_collection.performance.insertion_tests.results_for_boost_any_collection.environment1">GCC
          5.2 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/insert_any_gcc52_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase> <phrase
            role="aligncenter"><emphasis role="bold">Insertion, GCC 5.2 x64</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.insertion_tests.results_for_boost_any_collection.environment2">
          <title><link linkend="poly_collection.performance.insertion_tests.results_for_boost_any_collection.environment2">Clang
          3.9 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/insert_any_clang39_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase> <phrase
            role="aligncenter"><emphasis role="bold">Insertion, Clang 3.9 x64</emphasis></phrase>
          </para>
        </section>
      </section>
    </section>
    <section id="poly_collection.performance.processing_tests">
      <title><link linkend="poly_collection.performance.processing_tests">Processing
      tests</link></title>
      <para>
        Tests measure the time taken to traverse a container of size <emphasis>n</emphasis>
        (<emphasis>n</emphasis> between 10<superscript>3</superscript> and 10<superscript>7</superscript>) and execute an operation on each
        of its elements. The operation for <code><phrase role="identifier">boost</phrase><phrase
        role="special">::</phrase><phrase role="identifier">base_collection</phrase></code>
        and <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">function_collection</phrase></code> (and the associated
        baseline containers) is defined as
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">for_each_callable</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">for_each_callable</phrase><phrase role="special">():</phrase><phrase role="identifier">res</phrase><phrase role="special">{</phrase><phrase role="number">0</phrase><phrase role="special">}{}</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase><phrase role="special">()(</phrase><phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">){</phrase>
    <phrase role="identifier">res</phrase><phrase role="special">+=</phrase><phrase role="identifier">x</phrase><phrase role="special">(</phrase><phrase role="number">2</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase>

  <phrase role="keyword">int</phrase> <phrase role="identifier">res</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        whereas for <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">any_collection</phrase></code> we use
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">for_each_incrementable</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">for_each_incrementable</phrase><phrase role="special">():</phrase><phrase role="identifier">res</phrase><phrase role="special">{</phrase><phrase role="number">0</phrase><phrase role="special">}{}</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase><phrase role="special">()(</phrase><phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">){</phrase>
    <phrase role="special">++</phrase><phrase role="identifier">x</phrase><phrase role="special">;</phrase>
    <phrase role="special">++</phrase><phrase role="identifier">res</phrase><phrase role="special">;</phrase>
  <phrase role="special">}</phrase>

  <phrase role="keyword">int</phrase> <phrase role="identifier">res</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        The baseline container is tested with three different setups:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            Directly as initialized by the process described for the <link linkend="poly_collection.performance.insertion_tests">insertion
            tests</link>. The sequence of types is complex enough that CPU's branch
            prediction mechanisms are not able to fully anticipate it <footnote id="poly_collection.performance.processing_tests.f0">
            <para>
              This has been verified empirically: simpler cycles did indeed yield
              better execution times.
            </para>
            </footnote>. As elements are ordered according to their construction
            time, certain degree of memory contiguity is expected.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            With an extra post-insertion stage by which elements are sorted according
            to their <code><phrase role="keyword">typeid</phrase><phrase role="special">()</phrase></code>.
            This increases branch prediction efficiency at the expense of having
            worse cache friendliness.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            With an extra post-insertion stage that randomly shuffles all the elements
            in the container. This is the worst possible scenario both in terms of
            caching and branch prediction.
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        As for the polymorphic collection, three variations are measured:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            With <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
            role="identifier">for_each</phrase></code> (the same as the baseline
            container).
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Using <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
            role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase
            role="identifier">for_each</phrase></code>.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Using <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
            role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase
            role="identifier">for_each</phrase></code> with <link linkend="poly_collection.tutorial.algorithms.type_restitution"><emphasis>type
            restitution</emphasis></link> of <code><phrase role="identifier">T1</phrase></code>,
            <code><phrase role="identifier">T2</phrase></code> and <code><phrase
            role="identifier">T3</phrase></code>.
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        The figures show resulting times in nanoseconds/element. The horizontal axis
        is logarithmic.
      </para>
      <section id="poly_collection.performance.processing_tests.results_for_boost_base_collectio">
        <title><link linkend="poly_collection.performance.processing_tests.results_for_boost_base_collectio">Results
        for <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">base_collection</phrase></code></link></title>
        <section id="poly_collection.performance.processing_tests.results_for_boost_base_collectio.environment">
          <title><link linkend="poly_collection.performance.processing_tests.results_for_boost_base_collectio.environment">Visual
          Studio 2015 x86</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/for_each_base_vs2015_x86.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Processing, Visual Studio
            2015 x86</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.processing_tests.results_for_boost_base_collectio.environment0">
          <title><link linkend="poly_collection.performance.processing_tests.results_for_boost_base_collectio.environment0">Visual
          Studio 2015 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/for_each_base_vs2015_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Processing, Visual Studio
            2015 x64</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.processing_tests.results_for_boost_base_collectio.environment1">
          <title><link linkend="poly_collection.performance.processing_tests.results_for_boost_base_collectio.environment1">GCC
          5.2 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/for_each_base_gcc52_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Processing, GCC 5.2
            x64</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.processing_tests.results_for_boost_base_collectio.environment2">
          <title><link linkend="poly_collection.performance.processing_tests.results_for_boost_base_collectio.environment2">Clang
          3.9 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/for_each_base_clang39_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Processing, Clang 3.9
            x64</emphasis></phrase>
          </para>
        </section>
      </section>
      <section id="poly_collection.performance.processing_tests.results_for_boost_function_colle">
        <title><link linkend="poly_collection.performance.processing_tests.results_for_boost_function_colle">Results
        for <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">function_collection</phrase></code></link></title>
        <section id="poly_collection.performance.processing_tests.results_for_boost_function_colle.environment">
          <title><link linkend="poly_collection.performance.processing_tests.results_for_boost_function_colle.environment">Visual
          Studio 2015 x86</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/for_each_function_vs2015_x86.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Processing, Visual Studio
            2015 x86</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.processing_tests.results_for_boost_function_colle.environment0">
          <title><link linkend="poly_collection.performance.processing_tests.results_for_boost_function_colle.environment0">Visual
          Studio 2015 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/for_each_function_vs2015_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Processing, Visual Studio
            2015 x64</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.processing_tests.results_for_boost_function_colle.environment1">
          <title><link linkend="poly_collection.performance.processing_tests.results_for_boost_function_colle.environment1">GCC
          5.2 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/for_each_function_gcc52_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Processing, GCC 5.2
            x64</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.processing_tests.results_for_boost_function_colle.environment2">
          <title><link linkend="poly_collection.performance.processing_tests.results_for_boost_function_colle.environment2">Clang
          3.9 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/for_each_function_clang39_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Processing, Clang 3.9
            x64</emphasis></phrase>
          </para>
        </section>
      </section>
      <section id="poly_collection.performance.processing_tests.results_for_boost_any_collection">
        <title><link linkend="poly_collection.performance.processing_tests.results_for_boost_any_collection">Results
        for <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">any_collection</phrase></code></link></title>
        <section id="poly_collection.performance.processing_tests.results_for_boost_any_collection.environment">
          <title><link linkend="poly_collection.performance.processing_tests.results_for_boost_any_collection.environment">Visual
          Studio 2015 x86</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/for_each_any_vs2015_x86.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Processing, Visual Studio
            2015 x86</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.processing_tests.results_for_boost_any_collection.environment0">
          <title><link linkend="poly_collection.performance.processing_tests.results_for_boost_any_collection.environment0">Visual
          Studio 2015 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/for_each_any_vs2015_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Processing, Visual Studio
            2015 x64</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.processing_tests.results_for_boost_any_collection.environment1">
          <title><link linkend="poly_collection.performance.processing_tests.results_for_boost_any_collection.environment1">GCC
          5.2 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/for_each_any_gcc52_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase> <phrase
            role="aligncenter"><emphasis role="bold">Processing, GCC 5.2 x64</emphasis></phrase>
          </para>
        </section>
        <section id="poly_collection.performance.processing_tests.results_for_boost_any_collection.environment2">
          <title><link linkend="poly_collection.performance.processing_tests.results_for_boost_any_collection.environment2">Clang
          3.9 x64</link></title>
          <para>
            <phrase role="aligncenter"><inlinemediaobject>
    <imageobject><imagedata fileref="img/for_each_any_clang39_x64.png"/></imageobject>
  </inlinemediaobject>
</phrase>
            <phrase role="aligncenter"><emphasis role="bold">Processing, Clang 3.9
            x64</emphasis></phrase>
          </para>
        </section>
      </section>
    </section>
  </section>
  <section id="poly_collection.reference">
    <title><link linkend="poly_collection.reference">Reference</link></title>
    <section id="poly_collection.reference.polymorphism_models">
      <title><link linkend="poly_collection.reference.polymorphism_models">Polymorphism
      models</link></title>
      <para>
        The key aspect of dynamic polymorphism is the ability for a value of type
        <code><phrase role="identifier">T</phrase></code> to internally use another
        value of a possibily different type <code><phrase role="identifier">U</phrase></code>
        for the implementation of a given interface. Base/derived polymorphism is
        the classic model of dynamic polymorphism in C++, bot not the only possible
        one.
      </para>
      <para>
        Formally, a <emphasis>polymorphism model</emphasis> is defined by
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            A family <emphasis role="bold">Interface</emphasis> of permissible interface
            types and, for each <code><phrase role="identifier">I</phrase></code>
            &#x2208; <emphasis role="bold">Interface</emphasis>, the family <emphasis
            role="bold">Implementation</emphasis>(<code><phrase role="identifier">I</phrase></code>)
            of types satisfying <code><phrase role="identifier">I</phrase></code>.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            For a given interface type <code><phrase role="identifier">I</phrase></code>,
            an operation <emphasis role="bold">subobject</emphasis>(<code><phrase
            role="identifier">x</phrase></code>) that maps each value of an implementation
            type to its internally used value <code><phrase role="identifier">y</phrase></code>
            of a possibly different implementation type <footnote id="poly_collection.reference.polymorphism_models.f0">
            <para>
              This is a metalinguistic definition not directly expressible in C++.
              There are equivalent formulations that can indeed be realized in C++,
              but they add little to the comprehension of the concepts.
            </para>
            </footnote>.
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        Static polymorphism is the trivial case where <emphasis role="bold">subobject</emphasis>(<code><phrase
        role="identifier">x</phrase></code>) = <code><phrase role="identifier">x</phrase></code>
        for all <code><phrase role="identifier">x</phrase></code>. Base/derived polymorphism
        is characterized by:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            <emphasis role="bold">Interface</emphasis> = { <code><phrase role="identifier">Base</phrase></code>
            : <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
            role="identifier">is_polymorphic_v</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">Base</phrase><phrase role="special">&gt;</phrase></code>
            }.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <emphasis role="bold">Implementation</emphasis>(<code><phrase role="identifier">Base</phrase></code>)
            = { <code><phrase role="identifier">Derived</phrase></code> : <code><phrase
            role="identifier">std</phrase><phrase role="special">::</phrase><phrase
            role="identifier">is_base_of_v</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">Base</phrase><phrase role="special">,</phrase><phrase
            role="identifier">Derived</phrase><phrase role="special">&gt;</phrase></code>
            }.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <emphasis role="bold">subobject</emphasis>(<code><phrase role="identifier">x</phrase></code>)
            = <code><phrase role="keyword">static_cast</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">Derived</phrase><phrase role="special">&amp;&gt;(</phrase><phrase
            role="identifier">x</phrase><phrase role="special">)</phrase></code>
            with <code><phrase role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase
            role="identifier">x</phrase><phrase role="special">)==</phrase><phrase
            role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase
            role="identifier">Derived</phrase><phrase role="special">)</phrase></code>.
          </simpara>
        </listitem>
      </itemizedlist>
    </section>
    <section id="poly_collection.reference.polymorphic_containers">
      <title><link linkend="poly_collection.reference.polymorphic_containers">Polymorphic
      containers</link></title>
      <para>
        A <emphasis>polymorphic container</emphasis> is an object that stores objects
        of some type <code><phrase role="identifier">T</phrase></code> implementing
        a given interface <code><phrase role="identifier">I</phrase></code> under
        an implicitly associated polymorphism model. Polymorphic containers satisfy
        the requirements for <ulink url="http://en.cppreference.com/w/cpp/concept/Container"><emphasis
        role="bold"><code><phrase role="identifier">Container</phrase></code></emphasis></ulink>
        and <ulink url="http://en.cppreference.com/w/cpp/concept/AllocatorAwareContainer"><emphasis
        role="bold"><code><phrase role="identifier">AllocatorAwareContainer</phrase></code></emphasis></ulink>
        with the following modifications:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            Where it occurs, replace the requirement that <code><phrase role="identifier">T</phrase></code>
            be <ulink url="http://en.cppreference.com/w/cpp/concept/CopyInsertable"><emphasis
            role="bold"><code><phrase role="identifier">CopyInsertable</phrase></code></emphasis></ulink>,
            <ulink url="http://en.cppreference.com/w/cpp/concept/CopyAssignable"><emphasis
            role="bold"><code><phrase role="identifier">CopyAssignable</phrase></code></emphasis></ulink>,
            <ulink url="http://en.cppreference.com/w/cpp/concept/MoveInsertable"><emphasis
            role="bold"><code><phrase role="identifier">MoveInsertable</phrase></code></emphasis></ulink>,
            <ulink url="http://en.cppreference.com/w/cpp/concept/MoveAssignable"><emphasis
            role="bold"><code><phrase role="identifier">MoveAssignable</phrase></code></emphasis></ulink>
            or <ulink url="http://en.cppreference.com/w/cpp/concept/EqualityComparable"><emphasis
            role="bold"><code><phrase role="identifier">EqualityComparable</phrase></code></emphasis></ulink>,
            with the following semantic clause: may throw if some subobject in the
            container is not <ulink url="http://en.cppreference.com/w/cpp/concept/CopyConstructible"><emphasis
            role="bold"><code><phrase role="identifier">CopyConstructible</phrase></code></emphasis></ulink>
            (respectively, <ulink url="http://en.cppreference.com/w/cpp/concept/CopyAssignable"><emphasis
            role="bold"><code><phrase role="identifier">CopyAssignable</phrase></code></emphasis></ulink>,
            <ulink url="http://en.cppreference.com/w/cpp/concept/MoveConstructible"><emphasis
            role="bold"><code><phrase role="identifier">MoveConstructible</phrase></code></emphasis></ulink>,
            <ulink url="http://en.cppreference.com/w/cpp/concept/MoveAssignable"><emphasis
            role="bold"><code><phrase role="identifier">MoveAssignable</phrase></code></emphasis></ulink>,
            <ulink url="http://en.cppreference.com/w/cpp/concept/EqualityComparable"><emphasis
            role="bold"><code><phrase role="identifier">EqualityComparable</phrase></code></emphasis></ulink>).
          </simpara>
        </listitem>
      </itemizedlist>
      <section id="poly_collection.reference.polymorphic_containers.polymorphic_collections">
        <title><link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections">Polymorphic
        collections</link></title>
        <para>
          <emphasis>Polymorphic collections</emphasis> store their objects of type
          <code><phrase role="identifier">value_type</phrase></code> in <emphasis>segments</emphasis>
          dedicated to each of the types of the contained subojects. Only objects
          whose subobjects are of an <emphasis>acceptable</emphasis> type are allowed,
          where a type <code><phrase role="identifier">U</phrase></code> is said
          to be acceptable if
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              it implements the interface associated to the container,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              it is <ulink url="http://en.cppreference.com/w/cpp/concept/MoveConstructible"><emphasis
              role="bold"><code><phrase role="identifier">MoveConstructible</phrase></code></emphasis></ulink>,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              it is <ulink url="http://en.cppreference.com/w/cpp/concept/MoveAssignable"><emphasis
              role="bold"><code><phrase role="identifier">MoveAssignable</phrase></code></emphasis></ulink>
              or <ulink url="http://en.cppreference.com/w/cpp/types/is_move_constructible"><code><phrase
              role="identifier">std</phrase><phrase role="special">::</phrase><phrase
              role="identifier">is_nothrow_move_constructible</phrase><phrase role="special">&lt;</phrase><phrase
              role="identifier">U</phrase><phrase role="special">&gt;::</phrase><phrase
              role="identifier">value</phrase></code></ulink> is <code><phrase role="keyword">true</phrase></code>.
            </simpara>
          </listitem>
        </itemizedlist>
        <para>
          Polymorphic collections conform to the requirements of <link linkend="poly_collection.reference.polymorphic_containers"><emphasis
          role="bold"><code><phrase role="identifier">PolymorphicContainer</phrase></code></emphasis></link>
          with the following modfications and extra guarantees:
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              <code><phrase role="identifier">a</phrase><phrase role="special">==</phrase><phrase
              role="identifier">b</phrase></code> evaluates to <code><phrase role="keyword">true</phrase></code>
              iff for each non-empty segment of subojects of type <code><phrase role="identifier">U</phrase></code>
              in <code><phrase role="identifier">a</phrase></code> there is a segment
              of <code><phrase role="identifier">U</phrase></code> in <code><phrase
              role="identifier">b</phrase></code> with the same size and equal elements
              in the same order, and viceversa.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              No exceptions are thrown associated to some subobject type not being
              <ulink url="http://en.cppreference.com/w/cpp/concept/CopyAssignable"><emphasis
              role="bold"><code><phrase role="identifier">CopyAssignable</phrase></code></emphasis></ulink>,
              <ulink url="http://en.cppreference.com/w/cpp/concept/MoveConstructible"><emphasis
              role="bold"><code><phrase role="identifier">MoveConstructible</phrase></code></emphasis></ulink>
              or <ulink url="http://en.cppreference.com/w/cpp/concept/MoveAssignable"><emphasis
              role="bold"><code><phrase role="identifier">MoveAssignable</phrase></code></emphasis></ulink>.
            </simpara>
          </listitem>
        </itemizedlist>
        <para>
          A type <code><phrase role="identifier">U</phrase></code> is said to be
          <emphasis>registered</emphasis> into the collection if a (possibly empty)
          segment for <code><phrase role="identifier">U</phrase></code> has been
          created. Registered types continue to stay so for the duration of the container
          except if it is moved from, assigned to, or swapped.
        </para>
        <para>
          Each segment has an associated capacity indicating the maximum size that
          it can attain without reallocation. When the limit is exceeded (or explicitly
          through <code><phrase role="identifier">reserve</phrase></code>) new storage
          space is allocated with greater capacity and elements are moved.
        </para>
        <para>
          Collection traversal goes through the elements of the first segment, then
          the second, etc. The order in which segments are visited is unspecified
          but remains stable until a new segment is created.
        </para>
        <para>
          Besides <code><phrase role="identifier">iterator</phrase></code> and <code><phrase
          role="identifier">const_iterator</phrase></code>, there are iterator types
          <code><phrase role="identifier">local_base_iterator</phrase></code> and
          <code><phrase role="identifier">local_iterator</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">U</phrase><phrase role="special">&gt;</phrase></code>
          (and their <code><phrase role="identifier">const_</phrase></code> counterparts)
          whose objects can be used to iterate over the segment for <code><phrase
          role="identifier">U</phrase></code> (in the same order followed by global
          traversal). Local base iterators refer to <code><phrase role="identifier">value_type</phrase></code>,
          whereas (<code><phrase role="identifier">const_</phrase></code>)<code><phrase
          role="identifier">local_iterator</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">U</phrase><phrase role="special">&gt;</phrase></code>
          refers to <code><phrase role="identifier">U</phrase></code>. All local
          iterators model <ulink url="http://en.cppreference.com/w/cpp/concept/RandomAccessIterator"><emphasis
          role="bold"><code><phrase role="identifier">RandomAccessIterator</phrase></code></emphasis></ulink>.
          Local base iterators may not be used to iterate across segments, and comparing
          local base iterators associated to different segments is undefined behavior.
          A (const) local base iterator to a segment for <code><phrase role="identifier">U</phrase></code>
          can be explicitly converted to (<code><phrase role="identifier">const_</phrase></code>)<code><phrase
          role="identifier">local_iterator</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">U</phrase><phrase role="special">&gt;</phrase></code>
          pointing to the same position, and viceversa.
        </para>
        <para>
          Insertion and erasure do not invalidate iterators (global or local) except
          those from the insertion/erasure point to the end of the affected segment,
          if its capacity is not exceeded, or all iterators/references to the segment
          otherwise <footnote id="poly_collection.reference.polymorphic_containers.polymorphic_collections.f0">
          <para>
            The global <code><phrase role="identifier">end</phrase><phrase role="special">()</phrase></code>
            iterator lies outside any segment, hence it always remain valid.
          </para>
          </footnote>.
        </para>
        <para>
          For the description of the remaining requirements of polymorphic collections,
          we use the following notation:
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              <code><phrase role="identifier">C</phrase></code> is a polymorphic
              collection type,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">c</phrase></code> is an object of type
              <code><phrase role="identifier">C</phrase></code>, <code><phrase role="identifier">cc</phrase></code>
              is a possibly <code><phrase role="keyword">const</phrase></code> object
              of type <code><phrase role="identifier">C</phrase></code>,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">al</phrase></code> is a value of type
              <code><phrase role="identifier">C</phrase><phrase role="special">::</phrase><phrase
              role="identifier">allocator_type</phrase></code>,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">index</phrase></code> is a value of
              <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
              role="identifier">type_index</phrase></code>,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">U</phrase></code> is an acceptable
              type, <code><phrase role="identifier">Us</phrase><phrase role="special">...</phrase></code>
              is a template parameter pack of acceptable types,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">n</phrase></code> is a value of <code><phrase
              role="identifier">size_type</phrase></code>,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">t</phrase></code> is a value of a type
              <code><phrase role="identifier">T</phrase></code> implementing the
              interface associated to the collection,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">args</phrase><phrase role="special">...</phrase></code>
              is a function parameter pack of types <code><phrase role="identifier">Args</phrase><phrase
              role="special">&amp;&amp;...</phrase></code>,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">it</phrase></code> is a possibly const
              global iterator of <code><phrase role="identifier">c</phrase></code>,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">it1</phrase></code> and <code><phrase
              role="identifier">it2</phrase></code> are (same-typed) possibly const
              global iterators of a <code><phrase role="identifier">C</phrase></code>
              collection other than <code><phrase role="identifier">c</phrase></code>
              such that [<code><phrase role="identifier">it1</phrase></code>, <code><phrase
              role="identifier">it2</phrase></code>) is a valid range.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">lbit</phrase></code> is a possibly
              const local base iterator of <code><phrase role="identifier">c</phrase></code>,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">lbit1</phrase></code> and <code><phrase
              role="identifier">lbit2</phrase></code> are (same-typed) possibly const
              local base iterators of a <code><phrase role="identifier">C</phrase></code>
              collection other than <code><phrase role="identifier">c</phrase></code>
              such that [<code><phrase role="identifier">lbit1</phrase></code>,
              <code><phrase role="identifier">lbit2</phrase></code>) is a valid range.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">lit</phrase></code> is a (<code><phrase
              role="identifier">const_</phrase></code>)<code><phrase role="identifier">local_iterator</phrase><phrase
              role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase
              role="special">&gt;</phrase></code> of <code><phrase role="identifier">c</phrase></code>,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">lit1</phrase></code> and <code><phrase
              role="identifier">lit2</phrase></code> are (same-typed) (<code><phrase
              role="identifier">const_</phrase></code>)<code><phrase role="identifier">local_iterator</phrase><phrase
              role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase
              role="special">&gt;</phrase></code>s of a <code><phrase role="identifier">C</phrase></code>
              collection other than <code><phrase role="identifier">c</phrase></code>
              such that [<code><phrase role="identifier">lit1</phrase></code>, <code><phrase
              role="identifier">lit2</phrase></code>) is a valid range,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">i1</phrase></code> and <code><phrase
              role="identifier">i2</phrase></code> are iterators external to <code><phrase
              role="identifier">c</phrase></code> referring to <code><phrase role="identifier">T</phrase></code>
              such that [<code><phrase role="identifier">i1</phrase></code>, <code><phrase
              role="identifier">i2</phrase></code>) is a valid range,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">j1</phrase></code> and <code><phrase
              role="identifier">j2</phrase></code> are iterators external to <code><phrase
              role="identifier">c</phrase></code> such that [<code><phrase role="identifier">j1</phrase></code>,
              <code><phrase role="identifier">j2</phrase></code>) is a valid range,
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <code><phrase role="identifier">xit1</phrase></code> and <code><phrase
              role="identifier">xit2</phrase></code> are (same-typed) possibly const
              iterators (global or local) of <code><phrase role="identifier">c</phrase></code>
              such that [<code><phrase role="identifier">xit1</phrase></code>, <code><phrase
              role="identifier">xit2</phrase></code>) is a valid range.
            </simpara>
          </listitem>
        </itemizedlist>
        <section id="poly_collection.reference.polymorphic_containers.polymorphic_collections.types">
          <title><link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types">Types</link></title>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.local_base_iterator"/><code><phrase
            role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">local_base_iterator</phrase></code>
          </para>
          <para>
            <ulink url="http://en.cppreference.com/w/cpp/concept/RandomAccessIterator"><emphasis
            role="bold"><code><phrase role="identifier">RandomAccessIterator</phrase></code></emphasis></ulink>
            with same value type, difference type and pointer and reference types
            as <code><phrase role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">iterator</phrase></code>, valid for accessing elements
            of a given segment. Implicily convertible to <code><phrase role="identifier">C</phrase><phrase
            role="special">::</phrase><phrase role="identifier">const_local_base_iterator</phrase></code>,
            explicitly convertible to <code><phrase role="identifier">C</phrase><phrase
            role="special">::</phrase><phrase role="identifier">local_iterator</phrase><phrase
            role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase
            role="special">&gt;</phrase></code> if the segment it points to is actually
            that for <code><phrase role="identifier">U</phrase></code>.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_local_base_iterator"/><code><phrase
            role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">const_local_base_iterator</phrase></code>
          </para>
          <para>
            <ulink url="http://en.cppreference.com/w/cpp/concept/RandomAccessIterator"><emphasis
            role="bold"><code><phrase role="identifier">RandomAccessIterator</phrase></code></emphasis></ulink>
            with same value type, difference type and pointer and reference types
            as <code><phrase role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">const_iterator</phrase></code>, valid for accessing
            elements of a given segment. Explicitly convertible to <code><phrase
            role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">const_local_iterator</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;</phrase></code>
            if the segment it points to is actually that for <code><phrase role="identifier">U</phrase></code>.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.local_iterator"/><code><phrase
            role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">local_iterator</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;</phrase></code>
          </para>
          <para>
            <ulink url="http://en.cppreference.com/w/cpp/concept/RandomAccessIterator"><emphasis
            role="bold"><code><phrase role="identifier">RandomAccessIterator</phrase></code></emphasis></ulink>
            with value type <code><phrase role="identifier">U</phrase></code>, reference
            type <code><phrase role="identifier">U</phrase><phrase role="special">&amp;</phrase></code>,
            pointer type <code><phrase role="identifier">U</phrase><phrase role="special">*</phrase></code>
            and the same difference type as <code><phrase role="identifier">C</phrase><phrase
            role="special">::</phrase><phrase role="identifier">iterator</phrase></code>,
            valid for accessing elements of the segment for <code><phrase role="identifier">U</phrase></code>.
            Implicily convertible to <code><phrase role="identifier">C</phrase><phrase
            role="special">::</phrase><phrase role="identifier">const_local_iterator</phrase><phrase
            role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase
            role="special">&gt;</phrase></code>, explicitly convertible to <code><phrase
            role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">local_base_iterator</phrase></code>.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_local_iterator"/><code><phrase
            role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">const_local_iterator</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;</phrase></code>
          </para>
          <para>
            <ulink url="http://en.cppreference.com/w/cpp/concept/RandomAccessIterator"><emphasis
            role="bold"><code><phrase role="identifier">RandomAccessIterator</phrase></code></emphasis></ulink>
            with value type <code><phrase role="identifier">U</phrase></code>, reference
            type <code><phrase role="keyword">const</phrase> <phrase role="identifier">U</phrase><phrase
            role="special">&amp;</phrase></code>, pointer type <code><phrase role="keyword">const</phrase>
            <phrase role="identifier">U</phrase><phrase role="special">*</phrase></code>
            and the same difference type as <code><phrase role="identifier">C</phrase><phrase
            role="special">::</phrase><phrase role="identifier">iterator</phrase></code>,
            valid for accessing elements of the segment for <code><phrase role="identifier">U</phrase></code>.
            Explicitly convertible to <code><phrase role="identifier">C</phrase><phrase
            role="special">::</phrase><phrase role="identifier">const_local_base_iterator</phrase></code>.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_segment_info"/><code><phrase
            role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">const_segment_info</phrase></code>
          </para>
          <para>
            <ulink url="http://en.cppreference.com/w/cpp/concept/CopyConstructible"><emphasis
            role="bold"><code><phrase role="identifier">CopyConstructible</phrase></code></emphasis></ulink>
            and <ulink url="http://en.cppreference.com/w/cpp/concept/CopyAssignable"><emphasis
            role="bold"><code><phrase role="identifier">CopyAssignable</phrase></code></emphasis></ulink>
            type with information about a given segment of a collection. If <code><phrase
            role="identifier">ci</phrase></code> is a possibly <code><phrase role="keyword">const</phrase></code>
            object of type <code><phrase role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">const_segment_info</phrase></code> associated to the
            segment of <code><phrase role="identifier">c</phrase></code> for <code><phrase
            role="identifier">U</phrase></code>, then
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                <code><phrase role="identifier">ci</phrase><phrase role="special">.</phrase><phrase
                role="identifier">begin</phrase><phrase role="special">()==</phrase><phrase
                role="identifier">c</phrase><phrase role="special">.</phrase><phrase
                role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase
                role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase
                role="identifier">U</phrase><phrase role="special">))</phrase></code>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <code><phrase role="identifier">ci</phrase><phrase role="special">.</phrase><phrase
                role="identifier">cbegin</phrase><phrase role="special">()==</phrase><phrase
                role="identifier">c</phrase><phrase role="special">.</phrase><phrase
                role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase
                role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase
                role="identifier">U</phrase><phrase role="special">))</phrase></code>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <code><phrase role="identifier">ci</phrase><phrase role="special">.</phrase><phrase
                role="identifier">begin</phrase><phrase role="special">&lt;</phrase><phrase
                role="identifier">U</phrase><phrase role="special">&gt;()==</phrase><phrase
                role="identifier">c</phrase><phrase role="special">.</phrase><phrase
                role="identifier">cbegin</phrase><phrase role="special">&lt;</phrase><phrase
                role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <code><phrase role="identifier">ci</phrase><phrase role="special">.</phrase><phrase
                role="identifier">cbegin</phrase><phrase role="special">&lt;</phrase><phrase
                role="identifier">U</phrase><phrase role="special">&gt;()==</phrase><phrase
                role="identifier">c</phrase><phrase role="special">.</phrase><phrase
                role="identifier">begin</phrase><phrase role="special">&lt;</phrase><phrase
                role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <code><phrase role="identifier">ci</phrase><phrase role="special">.</phrase><phrase
                role="identifier">end</phrase><phrase role="special">()==</phrase><phrase
                role="identifier">c</phrase><phrase role="special">.</phrase><phrase
                role="identifier">cend</phrase><phrase role="special">(</phrase><phrase
                role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase
                role="identifier">U</phrase><phrase role="special">))</phrase></code>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <code><phrase role="identifier">ci</phrase><phrase role="special">.</phrase><phrase
                role="identifier">cend</phrase><phrase role="special">()==</phrase><phrase
                role="identifier">c</phrase><phrase role="special">.</phrase><phrase
                role="identifier">cend</phrase><phrase role="special">(</phrase><phrase
                role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase
                role="identifier">U</phrase><phrase role="special">))</phrase></code>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <code><phrase role="identifier">ci</phrase><phrase role="special">.</phrase><phrase
                role="identifier">end</phrase><phrase role="special">&lt;</phrase><phrase
                role="identifier">U</phrase><phrase role="special">&gt;()==</phrase><phrase
                role="identifier">c</phrase><phrase role="special">.</phrase><phrase
                role="identifier">cend</phrase><phrase role="special">&lt;</phrase><phrase
                role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <code><phrase role="identifier">ci</phrase><phrase role="special">.</phrase><phrase
                role="identifier">cend</phrase><phrase role="special">&lt;</phrase><phrase
                role="identifier">U</phrase><phrase role="special">&gt;()==</phrase><phrase
                role="identifier">c</phrase><phrase role="special">.</phrase><phrase
                role="identifier">end</phrase><phrase role="special">&lt;</phrase><phrase
                role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <code><phrase role="identifier">ci</phrase><phrase role="special">.</phrase><phrase
                role="identifier">type_index</phrase><phrase role="special">()==</phrase><phrase
                role="identifier">std</phrase><phrase role="special">::</phrase><phrase
                role="identifier">type_index</phrase><phrase role="special">(</phrase><phrase
                role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase
                role="identifier">U</phrase><phrase role="special">))</phrase></code>
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.segment_info"/><code><phrase
            role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">segment_info</phrase></code>
          </para>
          <para>
            <ulink url="http://en.cppreference.com/w/cpp/concept/CopyConstructible"><emphasis
            role="bold"><code><phrase role="identifier">CopyConstructible</phrase></code></emphasis></ulink>
            and <ulink url="http://en.cppreference.com/w/cpp/concept/CopyAssignable"><emphasis
            role="bold"><code><phrase role="identifier">CopyAssignable</phrase></code></emphasis></ulink>
            type publicly derived from <code><phrase role="identifier">C</phrase><phrase
            role="special">::</phrase><phrase role="identifier">const_segment_info</phrase></code>
            and exposing its public interface. Additionally, if <code><phrase role="identifier">i</phrase></code>
            is an object of type <code><phrase role="identifier">C</phrase><phrase
            role="special">::</phrase><phrase role="identifier">segment_info</phrase></code>
            associated to the segment of <code><phrase role="identifier">c</phrase></code>
            for <code><phrase role="identifier">U</phrase></code>, then
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                <code><phrase role="identifier">i</phrase><phrase role="special">.</phrase><phrase
                role="identifier">begin</phrase><phrase role="special">()==</phrase><phrase
                role="identifier">c</phrase><phrase role="special">.</phrase><phrase
                role="identifier">begin</phrase><phrase role="special">(</phrase><phrase
                role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase
                role="identifier">U</phrase><phrase role="special">))</phrase></code>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <code><phrase role="identifier">i</phrase><phrase role="special">.</phrase><phrase
                role="identifier">begin</phrase><phrase role="special">&lt;</phrase><phrase
                role="identifier">U</phrase><phrase role="special">&gt;()==</phrase><phrase
                role="identifier">c</phrase><phrase role="special">.</phrase><phrase
                role="identifier">begin</phrase><phrase role="special">&lt;</phrase><phrase
                role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <code><phrase role="identifier">i</phrase><phrase role="special">.</phrase><phrase
                role="identifier">end</phrase><phrase role="special">()==</phrase><phrase
                role="identifier">c</phrase><phrase role="special">.</phrase><phrase
                role="identifier">end</phrase><phrase role="special">(</phrase><phrase
                role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase
                role="identifier">U</phrase><phrase role="special">))</phrase></code>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <code><phrase role="identifier">i</phrase><phrase role="special">.</phrase><phrase
                role="identifier">end</phrase><phrase role="special">&lt;</phrase><phrase
                role="identifier">U</phrase><phrase role="special">&gt;()==</phrase><phrase
                role="identifier">c</phrase><phrase role="special">.</phrase><phrase
                role="identifier">end</phrase><phrase role="special">&lt;</phrase><phrase
                role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code>
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.segment_info_iterator"/><code><phrase
            role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">segment_info_iterator</phrase></code>
          </para>
          <para>
            <ulink url="http://en.cppreference.com/w/cpp/concept/InputIterator"><emphasis
            role="bold"><code><phrase role="identifier">InputIterator</phrase></code></emphasis></ulink>
            with value type and reference type <code><phrase role="identifier">C</phrase><phrase
            role="special">::</phrase><phrase role="identifier">segment_info</phrase></code>.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_segment_info_iterator"/><code><phrase
            role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">const_segment_info_iterator</phrase></code>
          </para>
          <para>
            <ulink url="http://en.cppreference.com/w/cpp/concept/InputIterator"><emphasis
            role="bold"><code><phrase role="identifier">InputIterator</phrase></code></emphasis></ulink>
            with value type and reference type <code><phrase role="identifier">C</phrase><phrase
            role="special">::</phrase><phrase role="identifier">const_segment_info</phrase></code>.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_segment_traversal_info"/><code><phrase
            role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">const_segment_traversal_info</phrase></code>
          </para>
          <para>
            <ulink url="http://en.cppreference.com/w/cpp/concept/CopyConstructible"><emphasis
            role="bold"><code><phrase role="identifier">CopyConstructible</phrase></code></emphasis></ulink>
            and <ulink url="http://en.cppreference.com/w/cpp/concept/CopyAssignable"><emphasis
            role="bold"><code><phrase role="identifier">CopyAssignable</phrase></code></emphasis></ulink>
            type with <code><phrase role="keyword">const</phrase></code> member functions
            <code><phrase role="identifier">begin</phrase></code>/<code><phrase role="identifier">cbegin</phrase></code>
            and <code><phrase role="identifier">end</phrase></code>/<code><phrase
            role="identifier">cend</phrase></code> returning <code><phrase role="identifier">C</phrase><phrase
            role="special">::</phrase><phrase role="identifier">const_segment_info_iterator</phrase></code>
            objects that span over a range of <code><phrase role="identifier">C</phrase><phrase
            role="special">::</phrase><phrase role="identifier">const_segment_info</phrase></code>
            objects.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.segment_traversal_info"/><code><phrase
            role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">segment_traversal_info</phrase></code>
          </para>
          <para>
            <ulink url="http://en.cppreference.com/w/cpp/concept/CopyConstructible"><emphasis
            role="bold"><code><phrase role="identifier">CopyConstructible</phrase></code></emphasis></ulink>
            and <ulink url="http://en.cppreference.com/w/cpp/concept/CopyAssignable"><emphasis
            role="bold"><code><phrase role="identifier">CopyAssignable</phrase></code></emphasis></ulink>
            type publicly derived from with <code><phrase role="identifier">C</phrase><phrase
            role="special">::</phrase><phrase role="identifier">const_segment_traversal_info</phrase></code>
            and exposing its public interface. Additionally, provides non-const member
            functions <code><phrase role="identifier">begin</phrase></code> and
            <code><phrase role="identifier">end</phrase></code> returning <code><phrase
            role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">segment_info_iterator</phrase></code> objects that
            span over an equivalent range of <code><phrase role="identifier">C</phrase><phrase
            role="special">::</phrase><phrase role="identifier">segment_info</phrase></code>
            objects.
          </para>
        </section>
        <section id="poly_collection.reference.polymorphic_containers.polymorphic_collections.construct_copy_destroy">
          <title><link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.construct_copy_destroy">Construct/copy/destroy</link></title>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.construct_copy_destroy.range_construction"/><code><phrase
            role="identifier">C</phrase><phrase role="special">(</phrase><phrase
            role="identifier">j1</phrase><phrase role="special">,</phrase><phrase
            role="identifier">j2</phrase><phrase role="special">)</phrase></code><sbr/>
            <code><phrase role="identifier">C</phrase> <phrase role="identifier">d</phrase><phrase
            role="special">(</phrase><phrase role="identifier">j1</phrase><phrase
            role="special">,</phrase><phrase role="identifier">j2</phrase><phrase
            role="special">)</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Requires:</emphasis> <code><phrase role="identifier">C</phrase><phrase
            role="special">::</phrase><phrase role="identifier">allocator_type</phrase></code>
            is <ulink url="http://en.cppreference.com/w/cpp/concept/DefaultConstructible"><emphasis
            role="bold"><code><phrase role="identifier">DefaultConstructible</phrase></code></emphasis></ulink>.
            [<code><phrase role="identifier">j1</phrase></code>, <code><phrase role="identifier">j2</phrase></code>)
            can be inserted into <code><phrase role="identifier">C</phrase></code>.<sbr/>
            <emphasis role="bold">Effects:</emphasis> Copy constructs the internal
            allocator from <code><phrase role="identifier">C</phrase><phrase role="special">::</phrase><phrase
            role="identifier">allocator_type</phrase><phrase role="special">()</phrase></code>.
            Internally calls <code><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">j1</phrase><phrase role="special">,</phrase><phrase
            role="identifier">j2</phrase><phrase role="special">)</phrase></code>
            on construction.
          </para>
          <para>
            <code><phrase role="identifier">C</phrase><phrase role="special">(</phrase><phrase
            role="identifier">j1</phrase><phrase role="special">,</phrase><phrase
            role="identifier">j2</phrase><phrase role="special">,</phrase><phrase
            role="identifier">al</phrase><phrase role="special">)</phrase></code><sbr/>
            <code><phrase role="identifier">C</phrase> <phrase role="identifier">d</phrase><phrase
            role="special">(</phrase><phrase role="identifier">j1</phrase><phrase
            role="special">,</phrase><phrase role="identifier">j2</phrase><phrase
            role="special">,</phrase><phrase role="identifier">al</phrase><phrase
            role="special">)</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Requires:</emphasis> [<code><phrase role="identifier">j1</phrase></code>,
            <code><phrase role="identifier">j2</phrase></code>) can be inserted into
            <code><phrase role="identifier">C</phrase></code>.<sbr/> <emphasis role="bold">Effects:</emphasis>
            Copy constructs the internal allocator from <code><phrase role="identifier">al</phrase></code>.
            Internally calls <code><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">j1</phrase><phrase role="special">,</phrase><phrase
            role="identifier">j2</phrase><phrase role="special">)</phrase></code>
            on construction.
          </para>
        </section>
        <section id="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration">
          <title><link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration">Type
          registration</link></title>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration.register_types"/><code><phrase
            role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">register_types</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">Us</phrase><phrase role="special">...&gt;()</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Effects:</emphasis> Registers (if needed) each
            of the indicated types in the collection.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration.is_registered"/><code><phrase
            role="identifier">cc</phrase><phrase role="special">.</phrase><phrase
            role="identifier">is_registered</phrase><phrase role="special">(</phrase><phrase
            role="identifier">index</phrase><phrase role="special">)</phrase></code><sbr/>
            <code><phrase role="identifier">cc</phrase><phrase role="special">.</phrase><phrase
            role="identifier">is_registered</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Returns:</emphasis> <code><phrase role="keyword">true</phrase></code>
            iff the indicated type is registered in the collection.
          </para>
        </section>
        <section id="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators">
          <title><link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators">Iterators</link></title>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"/>(1)
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">begin</phrase><phrase role="special">(</phrase><phrase
            role="identifier">index</phrase><phrase role="special">)</phrase></code><sbr/>
            (2) <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">begin</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code><sbr/>
            (3) <code><phrase role="keyword">const_cast</phrase><phrase role="special">&lt;</phrase><phrase
            role="keyword">const</phrase> <phrase role="identifier">C</phrase><phrase
            role="special">&amp;&gt;(</phrase><phrase role="identifier">c</phrase><phrase
            role="special">).</phrase><phrase role="identifier">begin</phrase><phrase
            role="special">(</phrase><phrase role="identifier">index</phrase><phrase
            role="special">)</phrase></code><sbr/> (4) <code><phrase role="identifier">cc</phrase><phrase
            role="special">.</phrase><phrase role="identifier">cbegin</phrase><phrase
            role="special">(</phrase><phrase role="identifier">index</phrase><phrase
            role="special">)</phrase></code><sbr/> (5) <code><phrase role="keyword">const_cast</phrase><phrase
            role="special">&lt;</phrase><phrase role="keyword">const</phrase> <phrase
            role="identifier">C</phrase><phrase role="special">&amp;&gt;(</phrase><phrase
            role="identifier">c</phrase><phrase role="special">).</phrase><phrase
            role="identifier">begin</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code><sbr/>
            (6) <code><phrase role="identifier">cc</phrase><phrase role="special">.</phrase><phrase
            role="identifier">cbegin</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Returns:</emphasis> A <code><phrase role="identifier">local_base_iterator</phrase></code>
            (1) or <code><phrase role="identifier">local_iterator</phrase><phrase
            role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase
            role="special">&gt;</phrase></code> (2) or <code><phrase role="identifier">const_local_base_iterator</phrase></code>
            (3,4) or <code><phrase role="identifier">const_local_iterator</phrase><phrase
            role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase
            role="special">&gt;</phrase></code> (5,6) to the beginning of the segment
            for the indicated type.<sbr/> <emphasis role="bold">Throws:</emphasis>
            If the indicated type is not registered.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"/>(1)
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">end</phrase><phrase role="special">(</phrase><phrase
            role="identifier">index</phrase><phrase role="special">)</phrase></code><sbr/>
            (2) <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">end</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code><sbr/>
            (3) <code><phrase role="keyword">const_cast</phrase><phrase role="special">&lt;</phrase><phrase
            role="keyword">const</phrase> <phrase role="identifier">C</phrase><phrase
            role="special">&amp;&gt;(</phrase><phrase role="identifier">c</phrase><phrase
            role="special">).</phrase><phrase role="identifier">end</phrase><phrase
            role="special">(</phrase><phrase role="identifier">index</phrase><phrase
            role="special">)</phrase></code><sbr/> (4) <code><phrase role="identifier">cc</phrase><phrase
            role="special">.</phrase><phrase role="identifier">cend</phrase><phrase
            role="special">(</phrase><phrase role="identifier">index</phrase><phrase
            role="special">)</phrase></code><sbr/> (5) <code><phrase role="keyword">const_cast</phrase><phrase
            role="special">&lt;</phrase><phrase role="keyword">const</phrase> <phrase
            role="identifier">C</phrase><phrase role="special">&amp;&gt;(</phrase><phrase
            role="identifier">c</phrase><phrase role="special">).</phrase><phrase
            role="identifier">end</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code><sbr/>
            (6) <code><phrase role="identifier">cc</phrase><phrase role="special">.</phrase><phrase
            role="identifier">cend</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Returns:</emphasis> A <code><phrase role="identifier">local_base_iterator</phrase></code>
            (1) or <code><phrase role="identifier">local_iterator</phrase><phrase
            role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase
            role="special">&gt;</phrase></code> (2) or <code><phrase role="identifier">const_local_base_iterator</phrase></code>
            (3,4) or <code><phrase role="identifier">const_local_iterator</phrase><phrase
            role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase
            role="special">&gt;</phrase></code> (5,6) to the end of the segment for
            the indicated type.<sbr/> <emphasis role="bold">Throws:</emphasis> If
            the indicated type is not registered.
          </para>
        </section>
        <para>
          <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.segment_traversal"/>(1)
          <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
          role="identifier">segment_traversal</phrase><phrase role="special">()</phrase></code><sbr/>
          (2) <code><phrase role="keyword">const_cast</phrase><phrase role="special">&lt;</phrase><phrase
          role="keyword">const</phrase> <phrase role="identifier">C</phrase><phrase
          role="special">&amp;&gt;(</phrase><phrase role="identifier">c</phrase><phrase
          role="special">).</phrase><phrase role="identifier">segment_traversal</phrase><phrase
          role="special">()</phrase></code>
        </para>
        <para>
          <emphasis role="bold">Returns:</emphasis> A <code><phrase role="identifier">segment_traversal_info</phrase></code>
          (1) or <code><phrase role="identifier">const_segment_traversal_info</phrase></code>
          (2) object spanning over a range of segment descriptors for the collection.
          The order in which segments are visited matches that of [<code><phrase
          role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase
          role="special">()</phrase></code>, <code><phrase role="identifier">c</phrase><phrase
          role="special">.</phrase><phrase role="identifier">end</phrase><phrase
          role="special">()</phrase></code>).
        </para>
        <section id="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity">
          <title><link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity">Capacity</link></title>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.empty"/><code><phrase
            role="identifier">cc</phrase><phrase role="special">.</phrase><phrase
            role="identifier">empty</phrase><phrase role="special">(</phrase><phrase
            role="identifier">index</phrase><phrase role="special">)</phrase></code><sbr/>
            <code><phrase role="identifier">cc</phrase><phrase role="special">.</phrase><phrase
            role="identifier">empty</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Returns:</emphasis> <code><phrase role="keyword">true</phrase></code>
            iff the segment for the indicated type exists and is empty.<sbr/> <emphasis
            role="bold">Throws:</emphasis> If the indicated type is not registered.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.size"/><code><phrase
            role="identifier">cc</phrase><phrase role="special">.</phrase><phrase
            role="identifier">size</phrase><phrase role="special">(</phrase><phrase
            role="identifier">index</phrase><phrase role="special">)</phrase></code><sbr/>
            <code><phrase role="identifier">cc</phrase><phrase role="special">.</phrase><phrase
            role="identifier">size</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Returns:</emphasis> The size of the segment for
            the indicated type.<sbr/> <emphasis role="bold">Throws:</emphasis> If
            the indicated type is not registered.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.max_size"/><code><phrase
            role="identifier">cc</phrase><phrase role="special">.</phrase><phrase
            role="identifier">max_size</phrase><phrase role="special">()</phrase></code>
          </para>
          <para>
            <emphasis role="bold">REVIEW THIS DESIGN DECISION</emphasis><sbr/> <emphasis
            role="bold">Returns:</emphasis> the minimum return value of <code><phrase
            role="identifier">max_size</phrase></code> for each of the segments of
            the collection, or <code><phrase role="identifier">std</phrase><phrase
            role="special">::</phrase><phrase role="identifier">numeric_limits</phrase><phrase
            role="special">&lt;</phrase><phrase role="identifier">size_type</phrase><phrase
            role="special">&gt;::</phrase><phrase role="identifier">max</phrase></code>
            if there are no segments.
          </para>
          <para>
            <code><phrase role="identifier">cc</phrase><phrase role="special">.</phrase><phrase
            role="identifier">max_size</phrase><phrase role="special">(</phrase><phrase
            role="identifier">index</phrase><phrase role="special">)</phrase></code><sbr/>
            <code><phrase role="identifier">cc</phrase><phrase role="special">.</phrase><phrase
            role="identifier">max_size</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Returns:</emphasis> The maximum size attainable
            by the segment for the indicated type.<sbr/> <emphasis role="bold">Throws:</emphasis>
            If the indicated type is not registered.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.capacity"/><code><phrase
            role="identifier">cc</phrase><phrase role="special">.</phrase><phrase
            role="identifier">capacity</phrase><phrase role="special">()</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Returns:</emphasis> the minimum return value of
            <code><phrase role="identifier">capacity</phrase></code> for each of
            the segments of the collection, or <code><phrase role="identifier">std</phrase><phrase
            role="special">::</phrase><phrase role="identifier">numeric_limits</phrase><phrase
            role="special">&lt;</phrase><phrase role="identifier">size_type</phrase><phrase
            role="special">&gt;::</phrase><phrase role="identifier">max</phrase></code>
            if there are no segments.
          </para>
          <para>
            <code><phrase role="identifier">cc</phrase><phrase role="special">.</phrase><phrase
            role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase
            role="identifier">index</phrase><phrase role="special">)</phrase></code><sbr/>
            <code><phrase role="identifier">cc</phrase><phrase role="special">.</phrase><phrase
            role="identifier">capacity</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code><sbr/>
          </para>
          <para>
            <emphasis role="bold">Returns:</emphasis> The maximum size that the segment
            for the indicated type can attain without requiring reallocation.<sbr/>
            <emphasis role="bold">Throws:</emphasis> If the indicated type is not
            registered.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.reserve"/><code><phrase
            role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase
            role="identifier">n</phrase><phrase role="special">)</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Effects:</emphasis> Calls <code><phrase role="identifier">reserve</phrase></code>
            with <code><phrase role="identifier">n</phrase></code> for each of the
            segments of the collection.
          </para>
          <para>
            (1) <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase
            role="identifier">index</phrase><phrase role="special">,</phrase><phrase
            role="identifier">n</phrase><phrase role="special">)</phrase></code><sbr/>
            (2) <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">reserve</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;(</phrase><phrase
            role="identifier">n</phrase><phrase role="special">)</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Effects:</emphasis> Throws if the type indicated
            by <code><phrase role="identifier">index</phrase></code> is not registered
            (1) or registers <code><phrase role="identifier">U</phrase></code> if
            needed (2). If <code><phrase role="identifier">n</phrase></code> is greater
            than the current capacity of the segmentfor the indicated type, new storage
            space is allocated with a capacity of at least <code><phrase role="identifier">n</phrase></code>
            and elements are moved there.<sbr/> <emphasis role="bold">Complexity:</emphasis>
            Linear in the size of the segment if reallocation happens, constant otherwise.<sbr/>
            <emphasis role="bold">Throws:</emphasis> <code><phrase role="identifier">std</phrase><phrase
            role="special">::</phrase><phrase role="identifier">length_error</phrase></code>
            if <code><phrase role="identifier">n</phrase></code> is greater than
            the return value of <code><phrase role="identifier">max_size</phrase></code>
            for the segment.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.shrink_to_fit"/><code><phrase
            role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">shrink_to_fit</phrase><phrase role="special">()</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Effects:</emphasis> Calls <code><phrase role="identifier">shrink_to_fit</phrase></code>
            for each of the segments of the collection.
          </para>
          <para>
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">shrink_to_fit</phrase><phrase role="special">(</phrase><phrase
            role="identifier">index</phrase><phrase role="special">)</phrase></code><sbr/>
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">shrink_to_fit</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Effects:</emphasis> Non-binding request to reduce
            memory usage while preserving the sequence of elements of the segment
            for the indicated type. May invalidate all iterators and references to
            the segment.<sbr/> <emphasis role="bold">Throws:</emphasis> If the indicated
            type is not registered.
          </para>
        </section>
        <section id="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers">
          <title><link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers">Modifiers</link></title>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.emplace"/>(1)
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">emplace</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;(</phrase><phrase
            role="identifier">args</phrase><phrase role="special">...)</phrase></code><sbr/>
            (2) <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">emplace_hint</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;(</phrase><phrase
            role="identifier">it</phrase><phrase role="special">,</phrase><phrase
            role="identifier">args</phrase><phrase role="special">...)</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Requires:</emphasis> <code><phrase role="identifier">U</phrase></code>
            is constructible from <code><phrase role="identifier">std</phrase><phrase
            role="special">::</phrase><phrase role="identifier">forward</phrase><phrase
            role="special">&lt;</phrase><phrase role="identifier">Args</phrase><phrase
            role="special">&gt;(</phrase><phrase role="identifier">args</phrase><phrase
            role="special">)...</phrase></code>.<sbr/> <emphasis role="bold">Effects:</emphasis>
            Registers <code><phrase role="identifier">U</phrase></code> (if needed)
            and inserts a new element with a subobject constructed from <code><phrase
            role="identifier">std</phrase><phrase role="special">::</phrase><phrase
            role="identifier">forward</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">Args</phrase><phrase role="special">&gt;(</phrase><phrase
            role="identifier">args</phrase><phrase role="special">)...</phrase></code>:
            (1) at the end of the segment for <code><phrase role="identifier">U</phrase></code>;
            (2) just before the position indicated by <code><phrase role="identifier">it</phrase></code>,
            if it points to the segment for <code><phrase role="identifier">U</phrase></code>,
            or at the end of the segment for <code><phrase role="identifier">U</phrase></code>
            otherwise.<sbr/> <emphasis role="bold">Returns:</emphasis> An <code><phrase
            role="identifier">iterator</phrase></code> to the newly inserted element.<sbr/>
            <emphasis role="bold">Complexity:</emphasis> Amortized constant time
            plus linear in the distance from the insertion position to the end of
            the segment.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.emplace_pos"/>(1)
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">emplace_pos</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;(</phrase><phrase
            role="identifier">lbit</phrase><phrase role="special">,</phrase><phrase
            role="identifier">args</phrase><phrase role="special">...)</phrase></code><sbr/>
            (2) <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">emplace_pos</phrase><phrase role="special">(</phrase><phrase
            role="identifier">lit</phrase><phrase role="special">,</phrase><phrase
            role="identifier">args</phrase><phrase role="special">...)</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Requires:</emphasis> <code><phrase role="identifier">U</phrase></code>
            is constructible from <code><phrase role="identifier">std</phrase><phrase
            role="special">::</phrase><phrase role="identifier">forward</phrase><phrase
            role="special">&lt;</phrase><phrase role="identifier">Args</phrase><phrase
            role="special">&gt;(</phrase><phrase role="identifier">args</phrase><phrase
            role="special">)...</phrase></code>. (1) <code><phrase role="identifier">lbit</phrase></code>
            points to the segment for <code><phrase role="identifier">U</phrase></code>.<sbr/>
            <emphasis role="bold">Effects:</emphasis> Inserts a new element with
            a subobject constructed from <code><phrase role="identifier">std</phrase><phrase
            role="special">::</phrase><phrase role="identifier">forward</phrase><phrase
            role="special">&lt;</phrase><phrase role="identifier">Args</phrase><phrase
            role="special">&gt;(</phrase><phrase role="identifier">args</phrase><phrase
            role="special">)...</phrase></code> just before the position indicated.<sbr/>
            <emphasis role="bold">Returns:</emphasis> A <code><phrase role="identifier">local_base_iterator</phrase></code>
            (1) or <code><phrase role="identifier">local_iterator</phrase><phrase
            role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase
            role="special">&gt;</phrase></code> (2) to the newly inserted element.<sbr/>
            <emphasis role="bold">Complexity:</emphasis> Amortized constant time
            plus linear in the distance from the insertion position to the end of
            the segment.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.insert"/>(1)
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">x</phrase><phrase role="special">)</phrase></code><sbr/>
            (2) <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">it</phrase><phrase role="special">,</phrase><phrase
            role="identifier">x</phrase><phrase role="special">)</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Effects:</emphasis> If the type of the subobject
            of <code><phrase role="identifier">t</phrase></code> is not registered,
            then if this type is <code><phrase role="identifier">T</phrase></code>
            and <code><phrase role="identifier">T</phrase></code> is acceptable,
            does the registration, otherwise throws. If <code><phrase role="identifier">t</phrase></code>
            is not a non-const rvalue expression and the type of its subobject is
            not <ulink url="http://en.cppreference.com/w/cpp/concept/CopyConstructible"><emphasis
            role="bold"><code><phrase role="identifier">CopyConstructible</phrase></code></emphasis></ulink>,
            throws. Inserts an element with a subobject move constructed or copy
            constructed from the subobject of <code><phrase role="identifier">t</phrase></code>:
            (1) at the end of the corresponding segment; (2) just before the position
            indicated by <code><phrase role="identifier">it</phrase></code>, if it
            points to the corresponding segment, or at the end of the segment otherwise.<sbr/>
            <emphasis role="bold">Returns:</emphasis> An <code><phrase role="identifier">iterator</phrase></code>
            to the newly inserted element.<sbr/> <emphasis role="bold">Complexity:</emphasis>
            Amortized constant time plus linear in the distance from the insertion
            position to the end of the segment.
          </para>
          <para>
            (1) <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">lbit</phrase><phrase role="special">,</phrase><phrase
            role="identifier">x</phrase><phrase role="special">)</phrase></code><sbr/>
            (2) <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">lit</phrase><phrase role="special">,</phrase><phrase
            role="identifier">x</phrase><phrase role="special">)</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Requires:</emphasis> The type of the subobject
            of <code><phrase role="identifier">t</phrase></code> corresponds to the
            indicated segment.<sbr/> <emphasis role="bold">Effects:</emphasis> Inserts
            an element with a subobject move constructed or copy constructed from
            the subobject of <code><phrase role="identifier">t</phrase></code> just
            before the position indicated.<sbr/> <emphasis role="bold">Returns:</emphasis>
            A <code><phrase role="identifier">local_base_iterator</phrase></code>
            (1) or <code><phrase role="identifier">local_iterator</phrase><phrase
            role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase
            role="special">&gt;</phrase></code> (2) to the newly inserted element.<sbr/>
            <emphasis role="bold">Complexity:</emphasis> Amortized constant time
            plus linear in the distance from the insertion position to the end of
            the segment.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.insert_range"/><code><phrase
            role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">i1</phrase><phrase role="special">,</phrase><phrase
            role="identifier">i2</phrase><phrase role="special">)</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Effects:</emphasis> Equivalent to <code><phrase
            role="keyword">while</phrase><phrase role="special">(</phrase><phrase
            role="identifier">i1</phrase><phrase role="special">!=</phrase><phrase
            role="identifier">i2</phrase><phrase role="special">)</phrase><phrase
            role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">i1</phrase><phrase role="special">++)</phrase></code>.
          </para>
          <para>
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">it1</phrase><phrase role="special">,</phrase><phrase
            role="identifier">it2</phrase><phrase role="special">)</phrase></code><sbr/>
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">lbit1</phrase><phrase role="special">,</phrase><phrase
            role="identifier">lbit2</phrase><phrase role="special">)</phrase></code><sbr/>
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">lit1</phrase><phrase role="special">,</phrase><phrase
            role="identifier">lit2</phrase><phrase role="special">)</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Effects:</emphasis> For each of the elements of
            the range in succession, registers the type of its subobject if needed
            and inserts it into the collection <footnote id="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.f0">
            <para>
              Note that, unlike <code><phrase role="identifier">c</phrase><phrase
              role="special">.</phrase><phrase role="identifier">insert</phrase><phrase
              role="special">(</phrase><phrase role="identifier">i1</phrase><phrase
              role="special">,</phrase><phrase role="identifier">i2</phrase><phrase
              role="special">)</phrase></code>, these versions do not throw due to
              type registration problems.
            </para>
            </footnote>.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.insert_hint_range"/><code><phrase
            role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">it</phrase><phrase role="special">,</phrase><phrase
            role="identifier">i1</phrase><phrase role="special">,</phrase><phrase
            role="identifier">i2</phrase><phrase role="special">)</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Effects:</emphasis> If <code><phrase role="identifier">it</phrase><phrase
            role="special">==</phrase><phrase role="identifier">c</phrase><phrase
            role="special">.</phrase><phrase role="identifier">end</phrase><phrase
            role="special">()</phrase></code>, equivalent to <code><phrase role="keyword">while</phrase><phrase
            role="special">(</phrase><phrase role="identifier">i1</phrase><phrase
            role="special">!=</phrase><phrase role="identifier">i2</phrase><phrase
            role="special">)</phrase><phrase role="identifier">c</phrase><phrase
            role="special">.</phrase><phrase role="identifier">insert</phrase><phrase
            role="special">(</phrase><phrase role="identifier">it</phrase><phrase
            role="special">,</phrase><phrase role="identifier">i1</phrase><phrase
            role="special">++)</phrase></code>, otherwise inserts each of the elements
            in [<code><phrase role="identifier">i1</phrase></code>, <code><phrase
            role="identifier">i2</phrase></code>) in succession with a hint pointing
            to <code><phrase role="special">*</phrase><phrase role="identifier">it</phrase></code>
            <footnote id="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.f1">
            <para>
              That is, the hint remains stable even if <code><phrase role="identifier">it</phrase></code>
              may become invalid due to reallocations.
            </para>
            </footnote>.
          </para>
          <para>
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">it</phrase><phrase role="special">,</phrase><phrase
            role="identifier">it1</phrase><phrase role="special">,</phrase><phrase
            role="identifier">it2</phrase><phrase role="special">)</phrase></code><sbr/>
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">it</phrase><phrase role="special">,</phrase><phrase
            role="identifier">lbit1</phrase><phrase role="special">,</phrase><phrase
            role="identifier">lbit2</phrase><phrase role="special">)</phrase></code><sbr/>
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">it</phrase><phrase role="special">,</phrase><phrase
            role="identifier">lit1</phrase><phrase role="special">,</phrase><phrase
            role="identifier">lit2</phrase><phrase role="special">)</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Effects:</emphasis> If <code><phrase role="identifier">it</phrase><phrase
            role="special">==</phrase><phrase role="identifier">c</phrase><phrase
            role="special">.</phrase><phrase role="identifier">end</phrase><phrase
            role="special">()</phrase></code>, equivalent to the corresponding hint-less
            version, otherwise for each of the elements in [<code><phrase role="identifier">i1</phrase></code>,
            <code><phrase role="identifier">i2</phrase></code>) in succession registers
            the type of its subobject if needed and inserts it into the collection
            with a hint pointing to <code><phrase role="special">*</phrase><phrase
            role="identifier">it</phrase></code> <footnote id="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.f2">
            <para>
              The two previous notes apply here.
            </para>
            </footnote>.
          </para>
          <para>
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">lbit</phrase><phrase role="special">,</phrase><phrase
            role="identifier">i1</phrase><phrase role="special">,</phrase><phrase
            role="identifier">i2</phrase><phrase role="special">)</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Requires:</emphasis> The subojects of elements
            in [<code><phrase role="identifier">i1</phrase></code>, <code><phrase
            role="identifier">i2</phrase></code>) are all of the type corresponding
            to the indicated segment.<sbr/> <emphasis role="bold">Effects:</emphasis>
            Inserts a range of elements with subobjects copy constructed from those
            in [<code><phrase role="identifier">i1</phrase></code>, <code><phrase
            role="identifier">i2</phrase></code>) just before <code><phrase role="identifier">lbit</phrase></code>.<sbr/>
            <emphasis role="bold">Returns:</emphasis> A <code><phrase role="identifier">local_base_iterator</phrase></code>
            to the beginning of the inserted range.
          </para>
          <para>
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">insert</phrase><phrase role="special">(</phrase><phrase
            role="identifier">lit</phrase><phrase role="special">,</phrase><phrase
            role="identifier">j1</phrase><phrase role="special">,</phrase><phrase
            role="identifier">j2</phrase><phrase role="special">)</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Requires:</emphasis> For each value <code><phrase
            role="identifier">x</phrase></code> in [<code><phrase role="identifier">j1</phrase></code>,
            <code><phrase role="identifier">j2</phrase></code>) either (a) <code><phrase
            role="identifier">x</phrase></code> is of a type implementing the interface
            associated to the collection and the subobject of <code><phrase role="identifier">x</phrase></code>
            is of type <code><phrase role="identifier">U</phrase></code> or (b)
            <code><phrase role="identifier">U</phrase></code> is constructible from
            <code><phrase role="identifier">x</phrase></code>.<sbr/> <emphasis role="bold">Effects:</emphasis>
            Inserts a range of elements with subobjects copy constructed (a) or constructed
            (b) from the values in [<code><phrase role="identifier">j1</phrase></code>,
            <code><phrase role="identifier">j2</phrase></code>) just before <code><phrase
            role="identifier">lit</phrase></code>.<sbr/> <emphasis role="bold">Returns:</emphasis>
            A <code><phrase role="identifier">local_iterator</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;</phrase></code>
            to the beginning of the inserted range.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.erase"/><code><phrase
            role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">erase</phrase><phrase role="special">(</phrase><phrase
            role="identifier">xit1</phrase><phrase role="special">)</phrase></code><sbr/>
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">erase</phrase><phrase role="special">(</phrase><phrase
            role="identifier">xit1</phrase><phrase role="special">,</phrase><phrase
            role="identifier">xit2</phrase><phrase role="special">)</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Effects:</emphasis> Erases the indicated element(s).<sbr/>
            <emphasis role="bold">Returns:</emphasis> A non-const iterator of the
            same category as <code><phrase role="identifier">xit</phrase></code>
            pointing to the position just after the erased element(s).<sbr/> <emphasis
            role="bold">Complexity:</emphasis> Linear on the number of elements erased
            plus the distance from the last one to the end of its segment.
          </para>
          <para>
            <anchor id="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.clear"/><code><phrase
            role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">clear</phrase><phrase role="special">()</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Effects:</emphasis> Erases all the elements of
            the container.<sbr/> <emphasis role="bold">Complexity:</emphasis> Linear.
          </para>
          <para>
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">clear</phrase><phrase role="special">(</phrase><phrase
            role="identifier">index</phrase><phrase role="special">)</phrase></code><sbr/>
            <code><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase
            role="identifier">clear</phrase><phrase role="special">&lt;</phrase><phrase
            role="identifier">U</phrase><phrase role="special">&gt;()</phrase></code>
          </para>
          <para>
            <emphasis role="bold">Effects:</emphasis> Erases all the elements of
            the segment for the indicated type.<sbr/> <emphasis role="bold">Complexity:</emphasis>
            Linear in the size of the segment.<sbr/> <emphasis role="bold">Throws:</emphasis>
            If the indicated type is not registered.
          </para>
        </section>
      </section>
    </section>
    <section id="poly_collection.reference.header_boost_poly_collection_exc">
      <title><link linkend="poly_collection.reference.header_boost_poly_collection_exc">Header
      <code><phrase role="string">&quot;boost/poly_collection/exception.hpp&quot;</phrase></code>
      synopsis</link></title>
      <para>
        All the collections in Boost.PolyCollection use the following exceptions
        (and only these) to signal various run-time problems with contained types:
      </para>
<programlisting><phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">{</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">poly_collection</phrase><phrase role="special">{</phrase>

<phrase role="keyword">struct</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_exc.class_unregistered_type">unregistered_type</link><phrase role="special">;</phrase>
<phrase role="keyword">struct</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_exc.class_not_copy_constructible">not_copy_constructible</link><phrase role="special">;</phrase>
<phrase role="keyword">struct</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_exc.class_not_equality_comparable">not_equality_comparable</link><phrase role="special">;</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace poly_collection */</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace boost */</phrase>
</programlisting>
      <section id="poly_collection.reference.header_boost_poly_collection_exc.class_unregistered_type">
        <title><link linkend="poly_collection.reference.header_boost_poly_collection_exc.class_unregistered_type">Class
        <code><phrase role="identifier">unregistered_type</phrase></code></link></title>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">unregistered_type</phrase><phrase role="special">:</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">logic_error</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">unregistered_type</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">info</phrase><phrase role="special">);</phrase>

  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase> <phrase role="identifier">info</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
        <para>
          <code><phrase role="identifier">unregistered_type</phrase></code> is thrown
          when an operation is requested on a type which does not yet have an associated
          segment.
        </para>
        <para>
          <code><phrase role="identifier">unregistered_type</phrase><phrase role="special">(</phrase><phrase
          role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase
          role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase
          role="special">&amp;</phrase> <phrase role="identifier">info</phrase><phrase
          role="special">);</phrase></code>
        </para>
        <para>
          <emphasis role="bold">Effects:</emphasis> Constructs an <code><phrase role="identifier">unregistered_type</phrase></code>
          object with the specified type information.
        </para>
      </section>
      <section id="poly_collection.reference.header_boost_poly_collection_exc.class_not_copy_constructible">
        <title><link linkend="poly_collection.reference.header_boost_poly_collection_exc.class_not_copy_constructible">Class
        <code><phrase role="identifier">not_copy_constructible</phrase></code></link></title>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">not_copy_constructible</phrase><phrase role="special">:</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">logic_error</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">not_copy_constructible</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">info</phrase><phrase role="special">);</phrase>

  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase> <phrase role="identifier">info</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
        <para>
          <code><phrase role="identifier">not_copy_constructible</phrase></code>
          is thrown when a copy operation is tried that involves a non-<ulink url="http://en.cppreference.com/w/cpp/concept/CopyConstructible"><emphasis
          role="bold"><code><phrase role="identifier">CopyConstructible</phrase></code></emphasis></ulink>
          type.
        </para>
        <para>
          <code><phrase role="identifier">not_copy_constructible</phrase><phrase
          role="special">(</phrase><phrase role="keyword">const</phrase> <phrase
          role="identifier">std</phrase><phrase role="special">::</phrase><phrase
          role="identifier">type_index</phrase><phrase role="special">&amp;</phrase>
          <phrase role="identifier">info</phrase><phrase role="special">);</phrase></code>
        </para>
        <para>
          <emphasis role="bold">Effects:</emphasis> Constructs a <code><phrase role="identifier">not_copy_constructible</phrase></code>
          object with the specified type information.
        </para>
      </section>
      <section id="poly_collection.reference.header_boost_poly_collection_exc.class_not_equality_comparable">
        <title><link linkend="poly_collection.reference.header_boost_poly_collection_exc.class_not_equality_comparable">Class
        <code><phrase role="identifier">not_equality_comparable</phrase></code></link></title>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">not_equality_comparable</phrase><phrase role="special">:</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">logic_error</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">not_equality_comparable</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">info</phrase><phrase role="special">);</phrase>

  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase> <phrase role="identifier">info</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
        <para>
          <code><phrase role="identifier">not_equality_comparable</phrase></code>
          is thrown when comparing two collections for (in)equality involves non-<ulink
          url="http://en.cppreference.com/w/cpp/concept/EqualityComparable"><emphasis
          role="bold"><code><phrase role="identifier">EqualityComparable</phrase></code></emphasis></ulink>
          type.
        </para>
        <para>
          <code><phrase role="identifier">not_equality_comparable</phrase><phrase
          role="special">(</phrase><phrase role="keyword">const</phrase> <phrase
          role="identifier">std</phrase><phrase role="special">::</phrase><phrase
          role="identifier">type_index</phrase><phrase role="special">&amp;</phrase>
          <phrase role="identifier">info</phrase><phrase role="special">);</phrase></code>
        </para>
        <para>
          <emphasis role="bold">Effects:</emphasis> Constructs a <code><phrase role="identifier">not_equality_comparable</phrase></code>
          object with the specified type information.
        </para>
      </section>
    </section>
    <section id="poly_collection.reference.header_boost_poly_collection_bas">
      <title><link linkend="poly_collection.reference.header_boost_poly_collection_bas">Header
      <code><phrase role="string">&quot;boost/poly_collection/base_collection_fwd.hpp&quot;</phrase></code>
      synopsis</link></title>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">memory</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">{</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">poly_collection</phrase><phrase role="special">{</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">=</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">&gt;&gt;</phrase>
<phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_ba0.class_template_base_collection"><code><phrase role="identifier">base_collection</phrase></code></link><phrase role="special">;</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase><phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace poly_collection */</phrase>

<phrase role="keyword">using</phrase> <phrase role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase role="identifier">base_collection</phrase><phrase role="special">;</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace boost */</phrase>
</programlisting>
      <para>
        Forward declares the class template <link linkend="poly_collection.reference.header_boost_poly_collection_ba0.class_template_base_collection"><code><phrase
        role="identifier">base_collection</phrase></code></link> and specifies its
        default template arguments. Forward declares associated free functions and
        brings <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase
        role="identifier">base_collection</phrase></code> to the <code><phrase role="identifier">boost</phrase></code>
        namespace.
      </para>
    </section>
    <section id="poly_collection.reference.header_boost_poly_collection_ba0">
      <title><link linkend="poly_collection.reference.header_boost_poly_collection_ba0">Header
      <code><phrase role="string">&quot;boost/poly_collection/base_collection.hpp&quot;</phrase></code>
      synopsis</link></title>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">poly_collection</phrase><phrase role="special">/</phrase><phrase role="identifier">base_collection_fwd</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">{</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">poly_collection</phrase><phrase role="special">{</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_ba0.class_template_base_collection"><code><phrase role="identifier">base_collection</phrase></code></link><phrase role="special">;</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase><phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace poly_collection */</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace boost */</phrase>
</programlisting>
      <section id="poly_collection.reference.header_boost_poly_collection_ba0.class_template_base_collection">
        <title><link linkend="poly_collection.reference.header_boost_poly_collection_ba0.class_template_base_collection">Class
        template <code><phrase role="identifier">base_collection</phrase></code></link></title>
        <para>
          <code><phrase role="identifier">base_collection</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">Base</phrase><phrase role="special">,</phrase><phrase
          role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase></code>
          is a <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections"><emphasis
          role="bold"><code><phrase role="identifier">PolymorphicCollection</phrase></code></emphasis></link>
          associated to the classic base/derived <link linkend="poly_collection.reference.polymorphism_models">polymorphism
          model</link>:
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              <emphasis role="bold">Interface</emphasis> = { <code><phrase role="identifier">Base</phrase></code>
              : <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
              role="identifier">is_polymorphic_v</phrase><phrase role="special">&lt;</phrase><phrase
              role="identifier">Base</phrase><phrase role="special">&gt;</phrase></code>
              }.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <emphasis role="bold">Implementation</emphasis>(<code><phrase role="identifier">Base</phrase></code>)
              = { <code><phrase role="identifier">Derived</phrase></code> : <code><phrase
              role="identifier">std</phrase><phrase role="special">::</phrase><phrase
              role="identifier">is_base_of_v</phrase><phrase role="special">&lt;</phrase><phrase
              role="identifier">Base</phrase><phrase role="special">,</phrase><phrase
              role="identifier">Derived</phrase><phrase role="special">&gt;</phrase></code>
              }.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <emphasis role="bold">subobject</emphasis>(<code><phrase role="identifier">x</phrase></code>)
              = <code><phrase role="keyword">static_cast</phrase><phrase role="special">&lt;</phrase><phrase
              role="identifier">Derived</phrase><phrase role="special">&amp;&gt;(</phrase><phrase
              role="identifier">x</phrase><phrase role="special">)</phrase></code>
              with <code><phrase role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase
              role="identifier">x</phrase><phrase role="special">)==</phrase><phrase
              role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase
              role="identifier">Derived</phrase><phrase role="special">)</phrase></code>.
            </simpara>
          </listitem>
        </itemizedlist>
<programlisting><code><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Base</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase></code>
<phrase role="keyword">class</phrase> <code><phrase role="identifier">base_collection</phrase></code>
<phrase role="special">{</phrase>
<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types"><emphasis>// types:</emphasis></link>

  <phrase role="keyword">using</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">=</phrase><code><phrase role="identifier">Base</phrase></code><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">=</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">size_type</phrase><phrase role="special">=</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">difference_type</phrase><phrase role="special">=</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ptrdiff_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">reference</phrase><phrase role="special">=</phrase><phrase role="identifier">value_type</phrase><phrase role="special">&amp;;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">const_reference</phrase><phrase role="special">=</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">pointer</phrase><phrase role="special">=</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator_traits</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">pointer</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">const_pointer</phrase><phrase role="special">=</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator_traits</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_pointer</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">const_iterator</phrase><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.local_base_iterator"><code><phrase role="identifier">local_base_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_local_base_iterator"><code><phrase role="identifier">const_local_base_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.local_iterator"><code><phrase role="identifier">local_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_local_iterator"><code><phrase role="identifier">const_local_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_segment_info"><code><phrase role="identifier">const_segment_info</phrase></code></link><phrase role="special">;</phrase>
  <phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.segment_info"><code><phrase role="identifier">segment_info</phrase></code></link><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.segment_info_iterator"><code><phrase role="identifier">segment_info_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_segment_info_iterator"><code><phrase role="identifier">const_segment_info_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_segment_traversal_info"><code><phrase role="identifier">const_segment_traversal_info</phrase></code></link><phrase role="special">;</phrase>
  <phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.segment_traversal_info"><code><phrase role="identifier">segment_traversal_info</phrase></code></link><phrase role="special">;</phrase>

  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.construct_copy_destroy"><emphasis>// construct/destroy/copy:</emphasis></link>

  <code><phrase role="identifier">base_collection</phrase></code><phrase role="special">();</phrase>
  <code><phrase role="identifier">base_collection</phrase></code><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <code><phrase role="identifier">base_collection</phrase></code><phrase role="special">&amp;);</phrase>
  <code><phrase role="identifier">base_collection</phrase></code><phrase role="special">(</phrase><code><phrase role="identifier">base_collection</phrase></code><phrase role="special">&amp;&amp;);</phrase>
  <phrase role="keyword">explicit</phrase> <code><phrase role="identifier">base_collection</phrase></code><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">al</phrase><phrase role="special">);</phrase>
  <code><phrase role="identifier">base_collection</phrase></code><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <code><phrase role="identifier">base_collection</phrase></code><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">al</phrase><phrase role="special">);</phrase>
  <code><phrase role="identifier">base_collection</phrase></code><phrase role="special">(</phrase><code><phrase role="identifier">base_collection</phrase></code><phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">al</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase>
  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.construct_copy_destroy.range_construction"><code><phrase role="identifier">base_collection</phrase></code></link><phrase role="special">(</phrase>
    <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">al</phrase><phrase role="special">=</phrase><phrase role="identifier">allocator_type</phrase><phrase role="special">{});</phrase>

  <code><phrase role="identifier">base_collection</phrase></code><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase><phrase role="keyword">const</phrase> <code><phrase role="identifier">base_collection</phrase></code><phrase role="special">&amp;);</phrase>
  <code><phrase role="identifier">base_collection</phrase></code><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase><code><phrase role="identifier">base_collection</phrase></code><phrase role="special">&amp;&amp;);</phrase>

  <phrase role="identifier">allocator_type</phrase> <phrase role="identifier">get_allocator</phrase><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration"><emphasis>// type registration:</emphasis></link>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration.register_types"><code><phrase role="identifier">register_types</phrase></code></link><phrase role="special">();</phrase>

  <phrase role="keyword">bool</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration.is_registered"><code><phrase role="identifier">is_registered</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">bool</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration.is_registered"><code><phrase role="identifier">is_registered</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators"><emphasis>// iterators:</emphasis></link>

  <phrase role="identifier">iterator</phrase>       <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">iterator</phrase>       <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">cbegin</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">cend</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">);</phrase>
  <phrase role="identifier">local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">);</phrase>
  <phrase role="identifier">const_local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">cbegin</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">cend</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">();</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">();</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">const_local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">const_local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">const_local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">cbegin</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">const_local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">cend</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">segment_traversal_info</phrase>       <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.segment_traversal"><code><phrase role="identifier">segment_traversal</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_segment_traversal_info</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.segment_traversal"><code><phrase role="identifier">segment_traversal</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity"><emphasis>// capacity:</emphasis></link>

  <phrase role="keyword">bool</phrase> <phrase role="identifier">empty</phrase><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">bool</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.empty"><code><phrase role="identifier">empty</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">bool</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.empty"><code><phrase role="identifier">empty</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">size_type</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.size"><code><phrase role="identifier">size</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.size"><code><phrase role="identifier">size</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.max_size"><code><phrase role="identifier">max_size</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.max_size"><code><phrase role="identifier">max_size</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.max_size"><code><phrase role="identifier">max_size</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.capacity"><code><phrase role="identifier">capacity</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.capacity"><code><phrase role="identifier">capacity</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.capacity"><code><phrase role="identifier">capacity</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.reserve"><code><phrase role="identifier">reserve</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.reserve"><code><phrase role="identifier">reserve</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">,</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase><phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.reserve"><code><phrase role="identifier">reserve</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.shrink_to_fit"><code><phrase role="identifier">shrink_to_fit</phrase></code></link><phrase role="special">();</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.shrink_to_fit"><code><phrase role="identifier">shrink_to_fit</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.shrink_to_fit"><code><phrase role="identifier">shrink_to_fit</phrase></code></link><phrase role="special">();</phrase>

  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers"><emphasis>// modifiers:</emphasis></link>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Args</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.emplace"><code><phrase role="identifier">emplace</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">Args</phrase><phrase role="special">&amp;&amp;...</phrase> <phrase role="identifier">args</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Args</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.emplace"><code><phrase role="identifier">emplace_hint</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">const_iterator</phrase> <phrase role="identifier">hint</phrase><phrase role="special">,</phrase><phrase role="identifier">Args</phrase><phrase role="special">&amp;&amp;...</phrase> <phrase role="identifier">args</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">LocalIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Args</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">auto</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.emplace_pos"><code><phrase role="identifier">emplace_pos</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">LocalIterator</phrase> <phrase role="identifier">pos</phrase><phrase role="special">,</phrase><phrase role="identifier">Args</phrase><phrase role="special">&amp;&amp;...</phrase> <phrase role="identifier">args</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.insert"><code><phrase role="identifier">insert</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">T</phrase><phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">CollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">auto</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.insert"><code><phrase role="identifier">insert</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">CollectionIterator</phrase> <phrase role="identifier">hint</phrase><phrase role="special">,</phrase><phrase role="identifier">T</phrase><phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.insert_range"><code><phrase role="identifier">insert</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">CollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.insert_hint_range"><code><phrase role="identifier">insert</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">CollectionIterator</phrase> <phrase role="identifier">hint</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">CollectionIterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">auto</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.erase"><code><phrase role="identifier">erase</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">CollectionIterator</phrase> <phrase role="identifier">pos</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">CollectionIterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">auto</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.erase"><code><phrase role="identifier">erase</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">CollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">CollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.clear"><code><phrase role="identifier">clear</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.clear"><code><phrase role="identifier">clear</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.clear"><code><phrase role="identifier">clear</phrase></code></link><phrase role="special">();</phrase>

  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase><code><phrase role="identifier">base_collection</phrase></code><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
<phrase role="special">};</phrase>
</programlisting>
      </section>
    </section>
    <section id="poly_collection.reference.header_boost_poly_collection_fun">
      <title><link linkend="poly_collection.reference.header_boost_poly_collection_fun">Header
      <code><phrase role="string">&quot;boost/poly_collection/function_collection_fwd.hpp&quot;</phrase></code>
      synopsis</link></title>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">memory</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">{</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">poly_collection</phrase><phrase role="special">{</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Signature</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti"><code><phrase role="identifier">function_collection_value_type</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">Signature</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">=</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">function_collection_value_type</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase role="special">&gt;&gt;</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_fu0.class_template_function_collecti"><code><phrase role="identifier">function_collection</phrase></code></link><phrase role="special">;</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace poly_collection */</phrase>

<phrase role="keyword">using</phrase> <phrase role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase role="identifier">function_collection</phrase><phrase role="special">;</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace boost */</phrase>
</programlisting>
      <para>
        Defines the alias template <link linkend="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti"><code><phrase
        role="identifier">function_collection_value_type</phrase></code></link> (the
        actual type it refers to, though, is merely forward declared). Forward declares
        the class template <link linkend="poly_collection.reference.header_boost_poly_collection_fu0.class_template_function_collecti"><code><phrase
        role="identifier">function_collection</phrase></code></link> and specifies
        its default template arguments. Forward declares associated free functions
        and brings <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase
        role="identifier">function_collection</phrase></code> to the <code><phrase
        role="identifier">boost</phrase></code> namespace.
      </para>
    </section>
    <section id="poly_collection.reference.header_boost_poly_collection_fu0">
      <title><link linkend="poly_collection.reference.header_boost_poly_collection_fu0">Header
      <code><phrase role="string">&quot;boost/poly_collection/function_collection.hpp&quot;</phrase></code>
      synopsis</link></title>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">poly_collection</phrase><phrase role="special">/</phrase><phrase role="identifier">function_collection_fwd</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">{</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">poly_collection</phrase><phrase role="special">{</phrase>

<phrase role="comment">// defines the type <link linkend="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti"><code><phrase role="identifier">function_collection_value_type</phrase></code></link> refers to</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_fu0.class_template_function_collecti"><code><phrase role="identifier">function_collection</phrase></code></link><phrase role="special">;</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace poly_collection */</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace boost */</phrase>
</programlisting>
      <section id="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti">
        <title><link linkend="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti">Alias
        template <code><phrase role="identifier">function_collection_value_type</phrase></code></link></title>
        <para>
          <code><phrase role="identifier">function_collection_value_type</phrase><phrase
          role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase
          role="special">&gt;</phrase></code> is the <code><phrase role="identifier">value_type</phrase></code>
          of <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase
          role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase></code>,
          where <code><phrase role="identifier">Signature</phrase></code> must be
          a type of the form <code><phrase role="identifier">R</phrase><phrase role="special">(</phrase><phrase
          role="identifier">Args</phrase><phrase role="special">...)</phrase></code>.
          <code><phrase role="identifier">function_collection_value_type</phrase><phrase
          role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase
          role="special">&gt;</phrase></code> wraps a reference to an object modeling
          <ulink url="http://en.cppreference.com/w/cpp/concept/Callable"><emphasis
          role="bold"><code><phrase role="identifier">Callable</phrase></code></emphasis></ulink>
          for the given <code><phrase role="identifier">Signature</phrase></code>.
          The interface provided partially replicates that of <ulink url="http://en.cppreference.com/w/cpp/utility/functional/function"><code><phrase
          role="identifier">std</phrase><phrase role="special">::</phrase><phrase
          role="identifier">function</phrase></code></ulink> and adds some extra
          facilities.
        </para>
        <para>
          In what follows, the name <emphasis><code><phrase role="identifier">function_collection_value_type_impl</phrase></code></emphasis>
          is used just for explanatory purposes in place of the actual class template
          name, which is implementation defined.
        </para>
<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Signature</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">using</phrase> <phrase role="identifier">function_collection_value_type</phrase><phrase role="special">=</phrase>
  <emphasis>function_collection_value_type_impl</emphasis><phrase role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase role="special">&gt;;</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Signature</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">class</phrase> <emphasis>function_collection_value_type_impl</emphasis><phrase role="special">;</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">R</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Args</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">class</phrase> <emphasis>function_collection_value_type_impl</emphasis><phrase role="special">&lt;</phrase><phrase role="identifier">R</phrase><phrase role="special">(</phrase><phrase role="identifier">Args</phrase><phrase role="special">...)&gt;</phrase>
<phrase role="special">{</phrase>
<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
  <phrase role="keyword">explicit</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti.operator_bool">operator bool</link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">R</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti.operator_call">operator()</link><phrase role="special">(</phrase><phrase role="identifier">Args</phrase><phrase role="special">...</phrase> <phrase role="identifier">args</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_info</phrase><phrase role="special">&amp;</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti.target_type">target_type</link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">T</phrase><phrase role="special">*</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti.target">target</link><phrase role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">*</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti.target">target</link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">operator</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti.operator_std_function">std::function&lt;R(Args...)&gt;</link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">void</phrase><phrase role="special">*</phrase>       <link linkend="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti.data">data</link><phrase role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">const</phrase> <phrase role="keyword">void</phrase><phrase role="special">*</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti.data">data</link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
        <para>
          <anchor id="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti.operator_bool"/><code><phrase
          role="keyword">explicit</phrase> <phrase role="keyword">operator</phrase>
          <phrase role="keyword">bool</phrase><phrase role="special">()</phrase><phrase
          role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase
          role="special">;</phrase></code>
        </para>
        <para>
          <emphasis role="bold">Returns:</emphasis> <code><phrase role="keyword">true</phrase></code>.
        </para>
        <para>
          <anchor id="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti.operator_call"/><code><phrase
          role="identifier">R</phrase> <phrase role="keyword">operator</phrase><phrase
          role="special">()(</phrase><phrase role="identifier">Args</phrase><phrase
          role="special">...</phrase> <phrase role="identifier">args</phrase><phrase
          role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase></code>
        </para>
        <para>
          <emphasis role="bold">Effects:</emphasis> <code><ulink url="http://en.cppreference.com/w/cpp/utility/functional/invoke"><emphasis><emphasis
          role="bold"><code><phrase role="identifier">INVOKE</phrase></code></emphasis></emphasis></ulink><phrase
          role="special">(</phrase><phrase role="identifier">f</phrase><phrase role="special">,</phrase><phrase
          role="identifier">std</phrase><phrase role="special">::</phrase><phrase
          role="identifier">forward</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">Args</phrase><phrase role="special">&gt;(</phrase><phrase
          role="identifier">args</phrase><phrase role="special">)...,</phrase><phrase
          role="identifier">R</phrase><phrase role="special">)</phrase></code>, where
          f is the wrapped callable object.<sbr/> <emphasis role="bold">Returns:</emphasis>
          Nothing if <code><phrase role="identifier">R</phrase></code> is <code><phrase
          role="keyword">void</phrase></code>, otherwise the return value of <code><ulink
          url="http://en.cppreference.com/w/cpp/utility/functional/invoke"><emphasis><emphasis
          role="bold"><code><phrase role="identifier">INVOKE</phrase></code></emphasis></emphasis></ulink><phrase
          role="special">(</phrase><phrase role="identifier">f</phrase><phrase role="special">,</phrase><phrase
          role="identifier">std</phrase><phrase role="special">::</phrase><phrase
          role="identifier">forward</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">Args</phrase><phrase role="special">&gt;(</phrase><phrase
          role="identifier">args</phrase><phrase role="special">)...,</phrase><phrase
          role="identifier">R</phrase><phrase role="special">)</phrase></code>.
        </para>
        <para>
          <anchor id="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti.target_type"/><code><phrase
          role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase
          role="special">::</phrase><phrase role="identifier">type_info</phrase><phrase
          role="special">&amp;</phrase> <phrase role="identifier">target_type</phrase><phrase
          role="special">()</phrase><phrase role="keyword">const</phrase> <phrase
          role="keyword">noexcept</phrase><phrase role="special">;</phrase></code>
        </para>
        <para>
          <emphasis role="bold">Returns:</emphasis> <code><phrase role="keyword">typeid</phrase><phrase
          role="special">(</phrase><phrase role="identifier">T</phrase><phrase role="special">)</phrase></code>
          where <code><phrase role="identifier">T</phrase></code> is the type of
          the wrapped callable object.
        </para>
        <para>
          <anchor id="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti.target"/><code><phrase
          role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase
          role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase
          role="special">&gt;</phrase> <phrase role="identifier">T</phrase><phrase
          role="special">*</phrase> <phrase role="identifier">target</phrase><phrase
          role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase
          role="special">;</phrase></code><sbr/> <code><phrase role="keyword">template</phrase><phrase
          role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase
          role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase
          role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase
          role="special">*</phrase> <phrase role="identifier">target</phrase><phrase
          role="special">()</phrase><phrase role="keyword">const</phrase> <phrase
          role="keyword">noexcept</phrase><phrase role="special">;</phrase></code>
        </para>
        <para>
          <emphasis role="bold">Returns:</emphasis> If <code><phrase role="identifier">target_type</phrase><phrase
          role="special">()==</phrase><phrase role="keyword">typeid</phrase><phrase
          role="special">(</phrase><phrase role="identifier">T</phrase><phrase role="special">)</phrase></code>
          a pointer to the wrapped callable object, otherwise <code><phrase role="keyword">nullptr</phrase></code>.
        </para>
        <para>
          <anchor id="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti.operator_std_function"/><code><phrase
          role="keyword">operator</phrase> <phrase role="identifier">std</phrase><phrase
          role="special">::</phrase><phrase role="identifier">function</phrase><phrase
          role="special">&lt;</phrase><phrase role="identifier">R</phrase><phrase
          role="special">(</phrase><phrase role="identifier">Args</phrase><phrase
          role="special">...)&gt;()</phrase><phrase role="keyword">const</phrase>
          <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase></code>
        </para>
        <para>
          <emphasis role="bold">Returns:</emphasis> A <code><phrase role="identifier">std</phrase><phrase
          role="special">::</phrase><phrase role="identifier">function</phrase><phrase
          role="special">&lt;</phrase><phrase role="identifier">R</phrase><phrase
          role="special">(</phrase><phrase role="identifier">Args</phrase><phrase
          role="special">...)&gt;</phrase></code> object holding a reference to the
          wrapped callable object.
        </para>
        <para>
          <anchor id="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti.data"/><code><phrase
          role="keyword">void</phrase><phrase role="special">*</phrase> <phrase role="identifier">data</phrase><phrase
          role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase
          role="special">;</phrase></code><sbr/> <code><phrase role="keyword">const</phrase>
          <phrase role="keyword">void</phrase><phrase role="special">*</phrase>
          <phrase role="identifier">data</phrase><phrase role="special">()</phrase><phrase
          role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase
          role="special">;</phrase></code>
        </para>
        <para>
          <emphasis role="bold">Returns:</emphasis> The address of the wrapped callable
          object.
        </para>
      </section>
      <section id="poly_collection.reference.header_boost_poly_collection_fu0.class_template_function_collecti">
        <title><link linkend="poly_collection.reference.header_boost_poly_collection_fu0.class_template_function_collecti">Class
        template <code><phrase role="identifier">function_collection</phrase></code></link></title>
        <para>
          <code><phrase role="identifier">function_collection</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase
          role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase></code>
          is a <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections"><emphasis
          role="bold"><code><phrase role="identifier">PolymorphicCollection</phrase></code></emphasis></link>
          associated to a dynamic <link linkend="poly_collection.reference.polymorphism_models">polymorphism
          model</link> based on call signature compatibility:
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              <emphasis role="bold">Interface</emphasis> = { <code><phrase role="identifier">Signature</phrase></code>
              : <code><phrase role="identifier">Signature</phrase></code> = <code><phrase
              role="identifier">R</phrase><phrase role="special">(</phrase><phrase
              role="identifier">Args</phrase><phrase role="special">...)</phrase></code>
              }.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <emphasis role="bold">Implementation</emphasis>(<code><phrase role="identifier">Signature</phrase></code>)
              = { <code><phrase role="identifier">Callable</phrase></code> : <code><phrase
              role="identifier">std</phrase><phrase role="special">::</phrase><phrase
              role="identifier">callable_v</phrase><phrase role="special">&lt;</phrase><phrase
              role="identifier">Callable</phrase><phrase role="special">(</phrase><phrase
              role="identifier">Args</phrase><phrase role="special">...),</phrase><phrase
              role="identifier">R</phrase><phrase role="special">&gt;</phrase></code>
              }.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <emphasis role="bold">subobject</emphasis>(<code><phrase role="identifier">x</phrase></code>)
              =<sbr/> <code><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase
              role="identifier">target</phrase><phrase role="special">&lt;</phrase><phrase
              role="identifier">T</phrase><phrase role="special">&gt;()</phrase></code>
              with <code><phrase role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase
              role="identifier">T</phrase><phrase role="special">)==</phrase><phrase
              role="identifier">x</phrase><phrase role="special">.</phrase><phrase
              role="identifier">target_type</phrase><phrase role="special">()</phrase></code>,
              if <code><phrase role="identifier">x</phrase></code> is an instantiation
              of <link linkend="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti"><code><phrase
              role="identifier">function_collection_value_type</phrase></code></link>,<sbr/>
              <code><phrase role="identifier">x</phrase></code>, otherwise.
            </simpara>
          </listitem>
        </itemizedlist>
<programlisting><code><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Signature</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase></code>
<phrase role="keyword">class</phrase> <code><phrase role="identifier">function_collection</phrase></code>
<phrase role="special">{</phrase>
<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types"><emphasis>// types:</emphasis></link>

  <phrase role="keyword">using</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">=</phrase><code><link linkend="poly_collection.reference.header_boost_poly_collection_fu0.alias_template_function_collecti"><code><phrase role="identifier">function_collection_value_type</phrase></code></link><phrase role="special">&lt;</phrase><phrase role="identifier">Signature</phrase><phrase role="special">&gt;</phrase></code><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">=</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">size_type</phrase><phrase role="special">=</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">difference_type</phrase><phrase role="special">=</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ptrdiff_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">reference</phrase><phrase role="special">=</phrase><phrase role="identifier">value_type</phrase><phrase role="special">&amp;;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">const_reference</phrase><phrase role="special">=</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">pointer</phrase><phrase role="special">=</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator_traits</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">pointer</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">const_pointer</phrase><phrase role="special">=</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator_traits</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_pointer</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">const_iterator</phrase><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.local_base_iterator"><code><phrase role="identifier">local_base_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_local_base_iterator"><code><phrase role="identifier">const_local_base_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.local_iterator"><code><phrase role="identifier">local_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_local_iterator"><code><phrase role="identifier">const_local_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_segment_info"><code><phrase role="identifier">const_segment_info</phrase></code></link><phrase role="special">;</phrase>
  <phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.segment_info"><code><phrase role="identifier">segment_info</phrase></code></link><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.segment_info_iterator"><code><phrase role="identifier">segment_info_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_segment_info_iterator"><code><phrase role="identifier">const_segment_info_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_segment_traversal_info"><code><phrase role="identifier">const_segment_traversal_info</phrase></code></link><phrase role="special">;</phrase>
  <phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.segment_traversal_info"><code><phrase role="identifier">segment_traversal_info</phrase></code></link><phrase role="special">;</phrase>

  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.construct_copy_destroy"><emphasis>// construct/destroy/copy:</emphasis></link>

  <code><phrase role="identifier">function_collection</phrase></code><phrase role="special">();</phrase>
  <code><phrase role="identifier">function_collection</phrase></code><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <code><phrase role="identifier">function_collection</phrase></code><phrase role="special">&amp;);</phrase>
  <code><phrase role="identifier">function_collection</phrase></code><phrase role="special">(</phrase><code><phrase role="identifier">function_collection</phrase></code><phrase role="special">&amp;&amp;);</phrase>
  <phrase role="keyword">explicit</phrase> <code><phrase role="identifier">function_collection</phrase></code><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">al</phrase><phrase role="special">);</phrase>
  <code><phrase role="identifier">function_collection</phrase></code><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <code><phrase role="identifier">function_collection</phrase></code><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">al</phrase><phrase role="special">);</phrase>
  <code><phrase role="identifier">function_collection</phrase></code><phrase role="special">(</phrase><code><phrase role="identifier">function_collection</phrase></code><phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">al</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase>
  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.construct_copy_destroy.range_construction"><code><phrase role="identifier">function_collection</phrase></code></link><phrase role="special">(</phrase>
    <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">al</phrase><phrase role="special">=</phrase><phrase role="identifier">allocator_type</phrase><phrase role="special">{});</phrase>

  <code><phrase role="identifier">function_collection</phrase></code><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase><phrase role="keyword">const</phrase> <code><phrase role="identifier">function_collection</phrase></code><phrase role="special">&amp;);</phrase>
  <code><phrase role="identifier">function_collection</phrase></code><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase><code><phrase role="identifier">function_collection</phrase></code><phrase role="special">&amp;&amp;);</phrase>

  <phrase role="identifier">allocator_type</phrase> <phrase role="identifier">get_allocator</phrase><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration"><emphasis>// type registration:</emphasis></link>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration.register_types"><code><phrase role="identifier">register_types</phrase></code></link><phrase role="special">();</phrase>

  <phrase role="keyword">bool</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration.is_registered"><code><phrase role="identifier">is_registered</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">bool</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration.is_registered"><code><phrase role="identifier">is_registered</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators"><emphasis>// iterators:</emphasis></link>

  <phrase role="identifier">iterator</phrase>       <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">iterator</phrase>       <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">cbegin</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">cend</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">);</phrase>
  <phrase role="identifier">local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">);</phrase>
  <phrase role="identifier">const_local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">cbegin</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">cend</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">();</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">();</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">const_local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">const_local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">const_local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">cbegin</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">const_local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">cend</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">segment_traversal_info</phrase>       <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.segment_traversal"><code><phrase role="identifier">segment_traversal</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_segment_traversal_info</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.segment_traversal"><code><phrase role="identifier">segment_traversal</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity"><emphasis>// capacity:</emphasis></link>

  <phrase role="keyword">bool</phrase> <phrase role="identifier">empty</phrase><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">bool</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.empty"><code><phrase role="identifier">empty</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">bool</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.empty"><code><phrase role="identifier">empty</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">size_type</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.size"><code><phrase role="identifier">size</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.size"><code><phrase role="identifier">size</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.max_size"><code><phrase role="identifier">max_size</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.max_size"><code><phrase role="identifier">max_size</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.max_size"><code><phrase role="identifier">max_size</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.capacity"><code><phrase role="identifier">capacity</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.capacity"><code><phrase role="identifier">capacity</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.capacity"><code><phrase role="identifier">capacity</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.reserve"><code><phrase role="identifier">reserve</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.reserve"><code><phrase role="identifier">reserve</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">,</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase><phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.reserve"><code><phrase role="identifier">reserve</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.shrink_to_fit"><code><phrase role="identifier">shrink_to_fit</phrase></code></link><phrase role="special">();</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.shrink_to_fit"><code><phrase role="identifier">shrink_to_fit</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.shrink_to_fit"><code><phrase role="identifier">shrink_to_fit</phrase></code></link><phrase role="special">();</phrase>

  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers"><emphasis>// modifiers:</emphasis></link>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Args</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.emplace"><code><phrase role="identifier">emplace</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">Args</phrase><phrase role="special">&amp;&amp;...</phrase> <phrase role="identifier">args</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Args</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.emplace"><code><phrase role="identifier">emplace_hint</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">const_iterator</phrase> <phrase role="identifier">hint</phrase><phrase role="special">,</phrase><phrase role="identifier">Args</phrase><phrase role="special">&amp;&amp;...</phrase> <phrase role="identifier">args</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">LocalIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Args</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">auto</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.emplace_pos"><code><phrase role="identifier">emplace_pos</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">LocalIterator</phrase> <phrase role="identifier">pos</phrase><phrase role="special">,</phrase><phrase role="identifier">Args</phrase><phrase role="special">&amp;&amp;...</phrase> <phrase role="identifier">args</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.insert"><code><phrase role="identifier">insert</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">T</phrase><phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">CollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">auto</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.insert"><code><phrase role="identifier">insert</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">CollectionIterator</phrase> <phrase role="identifier">hint</phrase><phrase role="special">,</phrase><phrase role="identifier">T</phrase><phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.insert_range"><code><phrase role="identifier">insert</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">CollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.insert_hint_range"><code><phrase role="identifier">insert</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">CollectionIterator</phrase> <phrase role="identifier">hint</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">CollectionIterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">auto</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.erase"><code><phrase role="identifier">erase</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">CollectionIterator</phrase> <phrase role="identifier">pos</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">CollectionIterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">auto</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.erase"><code><phrase role="identifier">erase</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">CollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">CollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.clear"><code><phrase role="identifier">clear</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.clear"><code><phrase role="identifier">clear</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.clear"><code><phrase role="identifier">clear</phrase></code></link><phrase role="special">();</phrase>

  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase><code><phrase role="identifier">function_collection</phrase></code><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
<phrase role="special">};</phrase>
</programlisting>
      </section>
    </section>
    <section id="poly_collection.reference.header_boost_poly_collection_any">
      <title><link linkend="poly_collection.reference.header_boost_poly_collection_any">Header
      <code><phrase role="string">&quot;boost/poly_collection/any_collection_fwd.hpp&quot;</phrase></code>
      synopsis</link></title>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">memory</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">{</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">poly_collection</phrase><phrase role="special">{</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Concept</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_an0.alias_template_any_collection_va"><code><phrase role="identifier">any_collection_value_type</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">Concept</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">=</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">any_collection_value_type</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase role="special">&gt;&gt;</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_an0.class_template_any_collection"><code><phrase role="identifier">any_collection</phrase></code></link><phrase role="special">;</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase><phrase role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace poly_collection */</phrase>

<phrase role="keyword">using</phrase> <phrase role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase role="identifier">any_collection</phrase><phrase role="special">;</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace boost */</phrase>
</programlisting>
      <para>
        Defines the alias template <link linkend="poly_collection.reference.header_boost_poly_collection_an0.alias_template_any_collection_va"><code><phrase
        role="identifier">any_collection_value_type</phrase></code></link> (the actual
        type it refers to, though, is merely forward declared). Forward declares
        the class template <link linkend="poly_collection.reference.header_boost_poly_collection_an0.class_template_any_collection"><code><phrase
        role="identifier">any_collection</phrase></code></link> and specifies its
        default template arguments. Forward declares associated free functions and
        brings <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">poly_collection</phrase><phrase role="special">::</phrase><phrase
        role="identifier">any_collection</phrase></code> to the <code><phrase role="identifier">boost</phrase></code>
        namespace.
      </para>
    </section>
    <section id="poly_collection.reference.header_boost_poly_collection_an0">
      <title><link linkend="poly_collection.reference.header_boost_poly_collection_an0">Header
      <code><phrase role="string">&quot;boost/poly_collection/any_collection.hpp&quot;</phrase></code>
      synopsis</link></title>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">poly_collection</phrase><phrase role="special">/</phrase><phrase role="identifier">any_collection_fwd</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">{</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">poly_collection</phrase><phrase role="special">{</phrase>

<phrase role="comment">// defines the type <link linkend="poly_collection.reference.header_boost_poly_collection_an0.alias_template_any_collection_va"><code><phrase role="identifier">any_collection_value_type</phrase></code></link> refers to</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.header_boost_poly_collection_an0.class_template_any_collection"><code><phrase role="identifier">any_collection</phrase></code></link><phrase role="special">;</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase><phrase role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace poly_collection */</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace boost */</phrase>
</programlisting>
      <section id="poly_collection.reference.header_boost_poly_collection_an0.alias_template_any_collection_va">
        <title><link linkend="poly_collection.reference.header_boost_poly_collection_an0.alias_template_any_collection_va">Alias
        template <code><phrase role="identifier">any_collection_value_type</phrase></code></link></title>
        <para>
          <code><phrase role="identifier">any_collection_value_type</phrase><phrase
          role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase
          role="special">&gt;</phrase></code> is the <code><phrase role="identifier">value_type</phrase></code>
          of <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase
          role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase></code>,
          where <code><phrase role="identifier">Concept</phrase></code> is defined
          according to the <ulink url="http://www.boost.org/doc/html/boost_typeerasure/conceptdef.html">requisites</ulink>
          of <ulink url="http://www.boost.org/libs/type_erasure">Boost.TypeErasure</ulink>
          using <ulink url="http://www.boost.org/doc/html/boost/type_erasure/_self.html"><code><phrase
          role="identifier">_self</phrase></code></ulink> as its <ulink url="http://www.boost.org/doc/html/boost/type_erasure/placeholder.html">placeholder</ulink>.
          The alias template definition has the form
        </para>
<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Concept</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">using</phrase> <phrase role="identifier">any_collection_value_type</phrase><phrase role="special">=</phrase>
  <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">type_erasure</phrase><phrase role="special">::</phrase><ulink url="http://www.boost.org/doc/html/boost/type_erasure/any.html">any</ulink><phrase role="special">&lt;</phrase><phrase role="identifier">Concept2</phrase><phrase role="special">,</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">type_erasure</phrase><phrase role="special">::</phrase><phrase role="identifier">_self</phrase><phrase role="special">&amp;&gt;;</phrase>
</programlisting>
        <para>
          with <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
          role="identifier">type_erasure</phrase><phrase role="special">::</phrase></code><ulink
          url="http://www.boost.org/doc/html/boost/type_erasure/is_subconcept.html"><code><phrase
          role="identifier">is_subconcept</phrase></code></ulink><code><phrase role="special">&lt;</phrase><phrase
          role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase
          role="identifier">Concept2</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value</phrase><phrase role="special">==</phrase><phrase
          role="keyword">true</phrase></code>. The exact definition of <code><phrase
          role="identifier">Concept2</phrase></code> is implementation defined.
        </para>
      </section>
      <section id="poly_collection.reference.header_boost_poly_collection_an0.class_template_any_collection">
        <title><link linkend="poly_collection.reference.header_boost_poly_collection_an0.class_template_any_collection">Class
        template <code><phrase role="identifier">any_collection</phrase></code></link></title>
        <para>
          <code><phrase role="identifier">any_collection</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase
          role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase></code>
          is a <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections"><emphasis
          role="bold"><code><phrase role="identifier">PolymorphicCollection</phrase></code></emphasis></link>
          associated to a dynamic <link linkend="poly_collection.reference.polymorphism_models">polymorphism
          model</link> based on <ulink url="https://en.wikipedia.org/wiki/Duck_typing"><emphasis>duck
          typing</emphasis></ulink> as implemented by <ulink url="http://www.boost.org/libs/type_erasure">Boost.TypeErasure</ulink>:
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              <emphasis role="bold">Interface</emphasis> = { <code><phrase role="identifier">Concept</phrase></code>
              : as <ulink url="http://www.boost.org/doc/html/boost_typeerasure/conceptdef.html">specified</ulink>
              by <ulink url="http://www.boost.org/libs/type_erasure">Boost.TypeErasure</ulink>,
              using the <ulink url="http://www.boost.org/doc/html/boost/type_erasure/_self.html"><code><phrase
              role="identifier">_self</phrase></code></ulink> <ulink url="http://www.boost.org/doc/html/boost/type_erasure/placeholder.html">placeholder</ulink>
              }.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <emphasis role="bold">Implementation</emphasis>(<code><phrase role="identifier">Concept</phrase></code>)
              = { <code><phrase role="identifier">Concrete</phrase></code> : <code><phrase
              role="identifier">Concrete</phrase></code> satisfies <code><phrase
              role="identifier">Concept</phrase></code> }.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <emphasis role="bold">subobject</emphasis>(<code><phrase role="identifier">x</phrase></code>)
              =<sbr/> <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
              role="identifier">type_erasure</phrase><phrase role="special">::</phrase></code><ulink
              url="http://www.boost.org/doc/html/boost/type_erasure/any_cast.html"><code><phrase
              role="identifier">any_cast</phrase></code></ulink><code><phrase role="special">&lt;</phrase><phrase
              role="identifier">T</phrase><phrase role="special">&amp;&gt;(</phrase><phrase
              role="identifier">x</phrase><phrase role="special">)</phrase></code>
              with <code><phrase role="keyword">typeid</phrase><phrase role="special">(</phrase><phrase
              role="identifier">T</phrase><phrase role="special">)==</phrase><phrase
              role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
              role="identifier">type_erasure</phrase><phrase role="special">::</phrase></code><ulink
              url="http://www.boost.org/doc/html/boost/type_erasure/typeid_of.html"><code><phrase
              role="identifier">typeid_of</phrase></code></ulink><code><phrase role="special">(</phrase><phrase
              role="identifier">x</phrase><phrase role="special">)</phrase></code>,
              if <code><phrase role="identifier">x</phrase></code> is an instantiation
              of <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
              role="identifier">type_erasure</phrase><phrase role="special">::</phrase></code><ulink
              url="http://www.boost.org/doc/html/boost/type_erasure/any.html"><code><phrase
              role="identifier">any</phrase></code></ulink> including <ulink url="http://www.boost.org/doc/html/boost/type_erasure/typeid_.html"><code><phrase
              role="identifier">typeid_</phrase></code></ulink><code><phrase role="special">&lt;&gt;</phrase></code>,<sbr/>
              <code><phrase role="identifier">x</phrase></code>, otherwise.
            </simpara>
          </listitem>
        </itemizedlist>
<programlisting><code><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Concept</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Allocator</phrase><phrase role="special">&gt;</phrase></code>
<phrase role="keyword">class</phrase> <code><phrase role="identifier">any_collection</phrase></code>
<phrase role="special">{</phrase>
<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types"><emphasis>// types:</emphasis></link>

  <phrase role="keyword">using</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">=</phrase><code><link linkend="poly_collection.reference.header_boost_poly_collection_an0.alias_template_any_collection_va"><code><phrase role="identifier">any_collection_value_type</phrase></code></link><phrase role="special">&lt;</phrase><phrase role="identifier">Concept</phrase><phrase role="special">&gt;</phrase></code><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">=</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">size_type</phrase><phrase role="special">=</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">difference_type</phrase><phrase role="special">=</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ptrdiff_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">reference</phrase><phrase role="special">=</phrase><phrase role="identifier">value_type</phrase><phrase role="special">&amp;;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">const_reference</phrase><phrase role="special">=</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">pointer</phrase><phrase role="special">=</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator_traits</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">pointer</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">const_pointer</phrase><phrase role="special">=</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator_traits</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Allocator</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_pointer</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">const_iterator</phrase><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.local_base_iterator"><code><phrase role="identifier">local_base_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_local_base_iterator"><code><phrase role="identifier">const_local_base_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.local_iterator"><code><phrase role="identifier">local_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_local_iterator"><code><phrase role="identifier">const_local_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_segment_info"><code><phrase role="identifier">const_segment_info</phrase></code></link><phrase role="special">;</phrase>
  <phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.segment_info"><code><phrase role="identifier">segment_info</phrase></code></link><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.segment_info_iterator"><code><phrase role="identifier">segment_info_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_segment_info_iterator"><code><phrase role="identifier">const_segment_info_iterator</phrase></code></link><phrase role="special">=</phrase><emphasis>implementation-defined</emphasis><phrase role="special">;</phrase>
  <phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.const_segment_traversal_info"><code><phrase role="identifier">const_segment_traversal_info</phrase></code></link><phrase role="special">;</phrase>
  <phrase role="keyword">class</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.types.segment_traversal_info"><code><phrase role="identifier">segment_traversal_info</phrase></code></link><phrase role="special">;</phrase>

  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.construct_copy_destroy"><emphasis>// construct/destroy/copy:</emphasis></link>

  <code><phrase role="identifier">any_collection</phrase></code><phrase role="special">();</phrase>
  <code><phrase role="identifier">any_collection</phrase></code><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <code><phrase role="identifier">any_collection</phrase></code><phrase role="special">&amp;);</phrase>
  <code><phrase role="identifier">any_collection</phrase></code><phrase role="special">(</phrase><code><phrase role="identifier">any_collection</phrase></code><phrase role="special">&amp;&amp;);</phrase>
  <phrase role="keyword">explicit</phrase> <code><phrase role="identifier">any_collection</phrase></code><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">al</phrase><phrase role="special">);</phrase>
  <code><phrase role="identifier">any_collection</phrase></code><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <code><phrase role="identifier">any_collection</phrase></code><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">al</phrase><phrase role="special">);</phrase>
  <code><phrase role="identifier">any_collection</phrase></code><phrase role="special">(</phrase><code><phrase role="identifier">any_collection</phrase></code><phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">al</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase>
  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.construct_copy_destroy.range_construction"><code><phrase role="identifier">any_collection</phrase></code></link><phrase role="special">(</phrase>
    <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">al</phrase><phrase role="special">=</phrase><phrase role="identifier">allocator_type</phrase><phrase role="special">{});</phrase>

  <code><phrase role="identifier">any_collection</phrase></code><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase><phrase role="keyword">const</phrase> <code><phrase role="identifier">any_collection</phrase></code><phrase role="special">&amp;);</phrase>
  <code><phrase role="identifier">any_collection</phrase></code><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase><code><phrase role="identifier">any_collection</phrase></code><phrase role="special">&amp;&amp;);</phrase>

  <phrase role="identifier">allocator_type</phrase> <phrase role="identifier">get_allocator</phrase><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration"><emphasis>// type registration:</emphasis></link>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration.register_types"><code><phrase role="identifier">register_types</phrase></code></link><phrase role="special">();</phrase>

  <phrase role="keyword">bool</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration.is_registered"><code><phrase role="identifier">is_registered</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">bool</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.type_registration.is_registered"><code><phrase role="identifier">is_registered</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators"><emphasis>// iterators:</emphasis></link>

  <phrase role="identifier">iterator</phrase>       <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">iterator</phrase>       <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">cbegin</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">cend</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">);</phrase>
  <phrase role="identifier">local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">);</phrase>
  <phrase role="identifier">const_local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">cbegin</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_local_base_iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">cend</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">();</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">();</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">const_local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">begin</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">const_local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">end</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">const_local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.begin"><code><phrase role="identifier">cbegin</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">const_local_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.end"><code><phrase role="identifier">cend</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">segment_traversal_info</phrase>       <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.segment_traversal"><code><phrase role="identifier">segment_traversal</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">const_segment_traversal_info</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.iterators.segment_traversal"><code><phrase role="identifier">segment_traversal</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity"><emphasis>// capacity:</emphasis></link>

  <phrase role="keyword">bool</phrase> <phrase role="identifier">empty</phrase><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">bool</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.empty"><code><phrase role="identifier">empty</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">bool</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.empty"><code><phrase role="identifier">empty</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">size_type</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.size"><code><phrase role="identifier">size</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.size"><code><phrase role="identifier">size</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.max_size"><code><phrase role="identifier">max_size</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.max_size"><code><phrase role="identifier">max_size</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.max_size"><code><phrase role="identifier">max_size</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.capacity"><code><phrase role="identifier">capacity</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.capacity"><code><phrase role="identifier">capacity</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">)</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">size_type</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.capacity"><code><phrase role="identifier">capacity</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.reserve"><code><phrase role="identifier">reserve</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.reserve"><code><phrase role="identifier">reserve</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">,</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase><phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.reserve"><code><phrase role="identifier">reserve</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.shrink_to_fit"><code><phrase role="identifier">shrink_to_fit</phrase></code></link><phrase role="special">();</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.shrink_to_fit"><code><phrase role="identifier">shrink_to_fit</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.capacity.shrink_to_fit"><code><phrase role="identifier">shrink_to_fit</phrase></code></link><phrase role="special">();</phrase>

  <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers"><emphasis>// modifiers:</emphasis></link>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Args</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.emplace"><code><phrase role="identifier">emplace</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">Args</phrase><phrase role="special">&amp;&amp;...</phrase> <phrase role="identifier">args</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Args</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.emplace"><code><phrase role="identifier">emplace_hint</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">const_iterator</phrase> <phrase role="identifier">hint</phrase><phrase role="special">,</phrase><phrase role="identifier">Args</phrase><phrase role="special">&amp;&amp;...</phrase> <phrase role="identifier">args</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">LocalIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Args</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">auto</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.emplace_pos"><code><phrase role="identifier">emplace_pos</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">LocalIterator</phrase> <phrase role="identifier">pos</phrase><phrase role="special">,</phrase><phrase role="identifier">Args</phrase><phrase role="special">&amp;&amp;...</phrase> <phrase role="identifier">args</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">iterator</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.insert"><code><phrase role="identifier">insert</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">T</phrase><phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">CollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">auto</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.insert"><code><phrase role="identifier">insert</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">CollectionIterator</phrase> <phrase role="identifier">hint</phrase><phrase role="special">,</phrase><phrase role="identifier">T</phrase><phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.insert_range"><code><phrase role="identifier">insert</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">CollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.insert_hint_range"><code><phrase role="identifier">insert</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">CollectionIterator</phrase> <phrase role="identifier">hint</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">CollectionIterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">auto</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.erase"><code><phrase role="identifier">erase</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">CollectionIterator</phrase> <phrase role="identifier">pos</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">CollectionIterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">auto</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.erase"><code><phrase role="identifier">erase</phrase></code></link><phrase role="special">(</phrase><phrase role="identifier">CollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">CollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.clear"><code><phrase role="identifier">clear</phrase></code></link><phrase role="special">()</phrase><phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.clear"><code><phrase role="identifier">clear</phrase></code></link><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">type_index</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">index</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">void</phrase> <link linkend="poly_collection.reference.polymorphic_containers.polymorphic_collections.modifiers.clear"><code><phrase role="identifier">clear</phrase></code></link><phrase role="special">();</phrase>

  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase><code><phrase role="identifier">any_collection</phrase></code><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
<phrase role="special">};</phrase>
</programlisting>
      </section>
    </section>
    <section id="poly_collection.reference.header_boost_poly_collection_alg">
      <title><link linkend="poly_collection.reference.header_boost_poly_collection_alg">Header
      <code><phrase role="string">&quot;boost/poly_collection/algorithm.hpp&quot;</phrase></code>
      synopsis</link></title>
<programlisting><phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">{</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">poly_collection</phrase><phrase role="special">{</phrase>

<emphasis><code><phrase role="comment">// non-modifying sequence operations:</phrase></code></emphasis>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="identifier">all_of</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase><phrase role="identifier">Predicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="identifier">any_of</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase><phrase role="identifier">Predicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="identifier">none_of</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase><phrase role="identifier">Predicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Function</phrase><phrase role="special">&gt;</phrase>
<phrase role="identifier">Function</phrase> <phrase role="identifier">for_each</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase><phrase role="identifier">Function</phrase> <phrase role="identifier">f</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
<phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">find</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase><phrase role="special">&gt;</phrase>
<phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">find_if</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase><phrase role="identifier">Predicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase><phrase role="special">&gt;</phrase>
<phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">find_if_not</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase><phrase role="identifier">Predicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">find_end</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">last2</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">find_end</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">last2</phrase><phrase role="special">,</phrase><phrase role="identifier">BinaryPredicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">find_first_of</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">last2</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">find_first_of</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">last2</phrase><phrase role="special">,</phrase><phrase role="identifier">BinaryPredicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">&gt;</phrase>
<phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">adjacent_find</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">adjacent_find</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">BinaryPredicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ptrdiff_t</phrase> <phrase role="identifier">count</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase><phrase role="special">&gt;</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ptrdiff_t</phrase> <phrase role="identifier">count_if</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase><phrase role="identifier">Predicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">mismatch</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">mismatch</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">BinaryPredicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">mismatch</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last2</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">mismatch</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last2</phrase><phrase role="special">,</phrase><phrase role="identifier">BinaryPredicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="identifier">equal</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="identifier">equal</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">BinaryPredicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="identifier">equal</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last2</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="identifier">equal</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last2</phrase><phrase role="special">,</phrase><phrase role="identifier">BinaryPredicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="identifier">is_permutation</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="identifier">is_permutation</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">BinaryPredicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="identifier">is_permutation</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">last2</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="identifier">is_permutation</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">last2</phrase><phrase role="special">,</phrase><phrase role="identifier">BinaryPredicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">search</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">last2</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">search</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">ForwardIterator</phrase> <phrase role="identifier">last2</phrase><phrase role="special">,</phrase><phrase role="identifier">BinaryPredicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Size</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">search_n</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">Size</phrase> <phrase role="identifier">count</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">Size</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">search_n</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">Size</phrase> <phrase role="identifier">count</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase><phrase role="identifier">BinaryPredicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<emphasis><code><phrase role="comment">// modifying sequence operations:</phrase></code></emphasis>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">copy</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">res</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">Size</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">copy_n</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">Size</phrase> <phrase role="identifier">count</phrase><phrase role="special">,</phrase><phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">res</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">copy_if</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">res</phrase><phrase role="special">,</phrase><phrase role="identifier">Predicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">move</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">res</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">UnaryOperation</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">transform</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">res</phrase><phrase role="special">,</phrase><phrase role="identifier">UnaryOperation</phrase> <phrase role="identifier">op</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryOperation</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">transform</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first1</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last1</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first2</phrase><phrase role="special">,</phrase><phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">res</phrase><phrase role="special">,</phrase><phrase role="identifier">BinaryOperation</phrase> <phrase role="identifier">op</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">replace_copy</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">res</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">old_x</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">new_x</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">replace_copy_if</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">res</phrase><phrase role="special">,</phrase><phrase role="identifier">Predicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">new_x</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">remove_copy</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">res</phrase><phrase role="special">,</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">remove_copy_if</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">res</phrase><phrase role="special">,</phrase><phrase role="identifier">Predicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">unique_copy</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">res</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">unique_copy</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">res</phrase><phrase role="special">,</phrase><phrase role="identifier">BinaryPredicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">rotate_copy</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">middle</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase><phrase role="identifier">OutputIterator</phrase> <phrase role="identifier">res</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">bool</phrase> <phrase role="identifier">is_partitioned</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase><phrase role="identifier">Predicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase>
  <phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator1</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator2</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase>
<phrase role="special">&gt;</phrase>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">OutputIterator1</phrase><phrase role="special">,</phrase><phrase role="identifier">OutputIterator2</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">partition_copy</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
  <phrase role="identifier">OutputIterator1</phrase> <phrase role="identifier">rest</phrase><phrase role="special">,</phrase><phrase role="identifier">OutputIterator2</phrase> <phrase role="identifier">resf</phrase><phrase role="special">,</phrase><phrase role="identifier">Predicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase><phrase role="special">...</phrase> <phrase role="identifier">Ts</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">PolyCollectionIterator</phrase><phrase role="special">,</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase><phrase role="special">&gt;</phrase>
<phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">partition_point</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">PolyCollectionIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase><phrase role="identifier">Predicate</phrase> <phrase role="identifier">pred</phrase><phrase role="special">);</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace poly_collection */</phrase>

<phrase role="special">}</phrase> <phrase role="comment">/* namespace boost */</phrase>
</programlisting>
      <para>
        The algorithms provided mimic the functionality of their homonyms in <ulink
        url="http://en.cppreference.com/w/cpp/algorithm"><code><phrase role="special">&lt;</phrase><phrase
        role="identifier">algorithm</phrase><phrase role="special">&gt;</phrase></code></ulink>
        but take advantage of the segmented nature of Boost.PolyCollection (global)
        iterators to deliver better performance. Additionally, concrete types can
        be passed to these algorithms for <emphasis>type restitution</emphasis>.
      </para>
      <para>
        For the description of the algorithms we use the following notation:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            <emphasis><code><phrase role="identifier">alg</phrase></code></emphasis>
            is the (unqualified) name of any of the algorithms in <code><phrase role="string">&quot;boost/poly_collection/algorithm.hpp&quot;</phrase></code>
            except <code><phrase role="identifier">copy_n</phrase></code> and <code><phrase
            role="identifier">rotate_copy</phrase></code>.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <code><phrase role="identifier">first</phrase></code>, <code><phrase
            role="identifier">middle</phrase></code> and <code><phrase role="identifier">last</phrase></code>
            are (same-typed) possibly const global iterators of a collection of Boost.PolyCollection
            such that [<code><phrase role="identifier">first</phrase></code>, <code><phrase
            role="identifier">middle</phrase></code>) and [<code><phrase role="identifier">middle</phrase></code>,
            <code><phrase role="identifier">last</phrase></code>) are valid ranges.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <code><phrase role="identifier">args</phrase><phrase role="special">...</phrase></code>
            is a function parameter pack of types <code><phrase role="identifier">Args</phrase><phrase
            role="special">&amp;&amp;...</phrase></code>,
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <code><phrase role="identifier">Ts</phrase><phrase role="special">...</phrase></code>
            is a template parameter pack of arbitrary types.
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        (1) <emphasis><code><phrase role="identifier">alg</phrase></code></emphasis><code><phrase
        role="special">(</phrase><phrase role="identifier">first</phrase><phrase
        role="special">,</phrase><phrase role="identifier">last</phrase><phrase role="special">,</phrase><phrase
        role="identifier">args</phrase><phrase role="special">...)</phrase></code><sbr/>
        (2) <code><phrase role="identifier">copy_n</phrase><phrase role="special">(</phrase><phrase
        role="identifier">first</phrase><phrase role="special">,</phrase><phrase
        role="identifier">args</phrase><phrase role="special">...)</phrase></code><sbr/>
        (3) <code><phrase role="identifier">rotate_copy</phrase><phrase role="special">(</phrase><phrase
        role="identifier">first</phrase><phrase role="special">,</phrase><phrase
        role="identifier">middle</phrase><phrase role="special">,</phrase><phrase
        role="identifier">last</phrase><phrase role="special">,</phrase><phrase role="identifier">args</phrase><phrase
        role="special">...)</phrase></code>
      </para>
      <para>
        <emphasis role="bold">Requires:</emphasis> The expression <code><phrase role="identifier">expr</phrase></code>
        is well-formed, where <code><phrase role="identifier">expr</phrase></code>
        is defined as:<sbr/> (1) <code><phrase role="identifier">std</phrase><phrase
        role="special">::</phrase></code><emphasis><code><phrase role="identifier">alg</phrase></code></emphasis><code><phrase
        role="special">(</phrase><phrase role="identifier">first</phrase><phrase
        role="special">,</phrase><phrase role="identifier">last</phrase><phrase role="special">,</phrase><phrase
        role="identifier">args</phrase><phrase role="special">...)</phrase></code>,<sbr/>
        (2) <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
        role="identifier">copy_n</phrase><phrase role="special">(</phrase><phrase
        role="identifier">first</phrase><phrase role="special">,</phrase><phrase
        role="identifier">args</phrase><phrase role="special">...)</phrase></code>,<sbr/>
        (3) <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
        role="identifier">rotate_copy</phrase><phrase role="special">(</phrase><phrase
        role="identifier">first</phrase><phrase role="special">,</phrase><phrase
        role="identifier">middle</phrase><phrase role="special">,</phrase><phrase
        role="identifier">last</phrase><phrase role="special">,</phrase><phrase role="identifier">args</phrase><phrase
        role="special">...)</phrase></code>.<sbr/> <emphasis role="bold">Effects:</emphasis>
        Equivalent to <code><phrase role="identifier">expr</phrase></code>.<sbr/>
        <emphasis role="bold">Returns:</emphasis> <code><phrase role="identifier">expr</phrase></code>.<sbr/>
        <emphasis role="bold">Complexity:</emphasis> That of <code><phrase role="identifier">expr</phrase></code>.
      </para>
      <para>
        (1) <emphasis><code><phrase role="identifier">alg</phrase></code></emphasis><code><phrase
        role="special">&lt;</phrase><phrase role="identifier">Ts</phrase><phrase
        role="special">...&gt;(</phrase><phrase role="identifier">first</phrase><phrase
        role="special">,</phrase><phrase role="identifier">last</phrase><phrase role="special">,</phrase><phrase
        role="identifier">args</phrase><phrase role="special">...)</phrase></code><sbr/>
        (2) <code><phrase role="identifier">copy_n</phrase><phrase role="special">&lt;</phrase><phrase
        role="identifier">Ts</phrase><phrase role="special">...&gt;(</phrase><phrase
        role="identifier">first</phrase><phrase role="special">,</phrase><phrase
        role="identifier">args</phrase><phrase role="special">...)</phrase></code><sbr/>
        (3) <code><phrase role="identifier">rotate_copy</phrase><phrase role="special">&lt;</phrase><phrase
        role="identifier">Ts</phrase><phrase role="special">...&gt;(</phrase><phrase
        role="identifier">first</phrase><phrase role="special">,</phrase><phrase
        role="identifier">middle</phrase><phrase role="special">,</phrase><phrase
        role="identifier">last</phrase><phrase role="special">,</phrase><phrase role="identifier">args</phrase><phrase
        role="special">...)</phrase></code>
      </para>
      <para>
        <emphasis role="bold">Requires:</emphasis> The expression <code><phrase role="identifier">expr</phrase></code>
        is well-formed, where <code><phrase role="identifier">expr</phrase></code>
        is defined as:<sbr/> (1) <code><phrase role="identifier">std</phrase><phrase
        role="special">::</phrase></code><emphasis><code><phrase role="identifier">alg</phrase></code></emphasis><code><phrase
        role="special">(</phrase><phrase role="identifier">rfirst</phrase><phrase
        role="special">,</phrase><phrase role="identifier">rlast</phrase><phrase
        role="special">,</phrase><phrase role="identifier">args</phrase><phrase role="special">...)</phrase></code>,<sbr/>
        (2) <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
        role="identifier">copy_n</phrase><phrase role="special">(</phrase><phrase
        role="identifier">rfirst</phrase><phrase role="special">,</phrase><phrase
        role="identifier">args</phrase><phrase role="special">...)</phrase></code>,<sbr/>
        (3) <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
        role="identifier">rotate_copy</phrase><phrase role="special">(</phrase><phrase
        role="identifier">rfirst</phrase><phrase role="special">,</phrase><phrase
        role="identifier">rmiddle</phrase><phrase role="special">,</phrase><phrase
        role="identifier">rlast</phrase><phrase role="special">,</phrase><phrase
        role="identifier">args</phrase><phrase role="special">...)</phrase></code>,<sbr/>
        and <code><phrase role="identifier">rfirst</phrase></code>, <code><phrase
        role="identifier">rmiddle</phrase></code> and <code><phrase role="identifier">rlast</phrase></code>
        are iterator-like objects behaving like their <code><phrase role="identifier">first</phrase></code>,
        <code><phrase role="identifier">middle</phrase></code> and <code><phrase
        role="identifier">last</phrase></code> counterparts except that they dereference
        to the corresponding subobject (<code><phrase role="keyword">const</phrase></code>)
        <code><phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase></code>
        if pointing to a segment for <code><phrase role="identifier">T</phrase></code>
        and <code><phrase role="identifier">T</phrase></code> is in <code><phrase
        role="identifier">Ts</phrase><phrase role="special">...</phrase></code>
        <footnote id="poly_collection.reference.header_boost_poly_collection_alg.f0">
        <para>
          Strictly speaking a proper <ulink url="http://en.cppreference.com/w/cpp/concept/ForwardIterator"><emphasis
          role="bold"><code><phrase role="identifier">ForwardIterator</phrase></code></emphasis></ulink>
          cannot behave like this as dereferencing must yield <emphasis>exactly</emphasis>
          a (<code><phrase role="keyword">const</phrase></code>) <code><phrase role="identifier">value_type</phrase><phrase
          role="special">&amp;</phrase></code> value, which disallows this type of
          polymorphism.
        </para>
        </footnote>.<sbr/> <emphasis role="bold">Effects:</emphasis> Equivalent to
        <code><phrase role="identifier">expr</phrase></code>.<sbr/> <emphasis role="bold">Returns:</emphasis>
        <code><phrase role="identifier">expr</phrase></code>.<sbr/> <emphasis role="bold">Complexity:</emphasis>
        That of <code><phrase role="identifier">expr</phrase></code>.
      </para>
    </section>
  </section>
  <section id="poly_collection.acknowledgments">
    <title><link linkend="poly_collection.acknowledgments">Acknowledgments</link></title>
    <para>
      The library uses <ulink url="http://www.pdimov.com/">Peter Dimov</ulink>'s
      <ulink url="http://www.pdimov.com/cpp2/simple_cxx11_metaprogramming.html">implementation
      of <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
      role="identifier">make_index_sequence</phrase></code></ulink>. <ulink url="http://manu343726.github.io/">Manu
      Sánchez</ulink> aided immensely with CI setup and performance testing. <ulink
      url="http://stackoverflow.com/users/85371/sehe">Sehe</ulink> contributed performance
      results for GCC 5.2, and <ulink url="https://www.linkedin.com/in/francisco-jose-tapia-iba%C3%B1ez-4239a07a">Francisco
      José Tapia</ulink> for Clang 3.9.
    </para>
    <para>
      Boost.PolyCollection was designed and written between rainy <ulink url="https://es.wikipedia.org/wiki/Viav%C3%A9lez">Viavélez</ulink>,
      noisy Madrid and beautiful <ulink url="https://en.wikipedia.org/wiki/C%C3%A1ceres%2c_Spain">Cáceres</ulink>,
      August-November, 2016.
    </para>
  </section>
</library>
